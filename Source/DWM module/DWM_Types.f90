!STARTOFREGISTRYGENERATEDFILE './DWM_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.03.02, 17-Sept-2014)
!*********************************************************************************************************************************
! DWM_Types
!.................................................................................................................................
! This file is part of DWM.
!
! Copyright (C) 2012-2014 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE DWM_Types
! This module contains all of the user-defined types needed in DWM. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE Reg-InflowWind.txt_Types
USE NWTC_Library
IMPLICIT NONE
! =========  CVSD  =======
  TYPE, PUBLIC :: CVSD
    INTEGER(IntKi)  :: counter = 0      !  [-]
    REAL(ReKi)  :: Denominator = 0.0      !  [-]
    REAL(ReKi)  :: Numerator = 0.0      !  [-]
  END TYPE CVSD
! =======================
! =========  turbine_average_velocity_data  =======
  TYPE, PUBLIC :: turbine_average_velocity_data
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: average_velocity_array_temp      ! the average velocity of the whole blade sections in a specific time step [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: average_velocity_array      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: swept_area      !  [m2]
    INTEGER(IntKi)  :: time_step_velocity = -1      !  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: time_step_velocity_array      !  [-]
    INTEGER(IntKi)  :: time_step_pass_velocity = -1      !  [-]
    INTEGER(IntKi)  :: time_step_force = -1      !  [-]
  END TYPE turbine_average_velocity_data
! =======================
! =========  DWM_Wake_Deficit_Data  =======
  TYPE, PUBLIC :: DWM_Wake_Deficit_Data
    INTEGER(IntKi)  :: np_x      ! point per axial distance [-]
    REAL(ReKi)  :: X_length      ! normalized length in axial direction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Turb_Stress_DWM      !  [-]
    INTEGER(IntKi)  :: n_x_vector      !  [-]
    INTEGER(IntKi)  :: n_r_vector      !  [-]
    REAL(ReKi)  :: ppR      ! Point_per_R_resoulution [-]
  END TYPE DWM_Wake_Deficit_Data
! =======================
! =========  MeanderData  =======
  TYPE, PUBLIC :: MeanderData
    INTEGER(IntKi)  :: scale_factor      !  [-]
    INTEGER(IntKi)  :: moving_time      !  [-]
  END TYPE MeanderData
! =======================
! =========  read_turbine_position_data  =======
  TYPE, PUBLIC :: read_turbine_position_data
    INTEGER(IntKi)  :: SimulationOrder_index      !  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: Turbine_sort_order      !  [-]
    INTEGER(IntKi)  :: WT_index      ! wind turbine index in the wind farm [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: TurbineInfluenceData      !  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: upwind_turbine_index      ! the upwind turbines that affecting this turbine [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: downwind_turbine_index      !  [-]
    INTEGER(IntKi)  :: upwindturbine_number      ! the number of upwind turbines affecting the downwind turbine [-]
    INTEGER(IntKi)  :: downwindturbine_number      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: turbine_windorigin_length      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: upwind_turbine_projected_distance      ! the projected distance between two turbines [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: downwind_turbine_projected_distance      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: turbine_angle      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: upwind_align_angle      ! the angle beween the line connecting the upwind turbine and this turbine and the wind direction vector [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: downwind_align_angle      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: upwind_turbine_Xcoor      ! the coordinate of the upwind turbine which affects this investigated turbine [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: upwind_turbine_Ycoor      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: wind_farm_Xcoor      ! the coordinates of all the turbines in the wind farm [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: wind_farm_Ycoor      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: downwind_turbine_Xcoor      ! the coordinate of the downwind turbine which is affected by this investigated turbine [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: downwind_turbine_Ycoor      !  [-]
  END TYPE read_turbine_position_data
! =======================
! =========  WeiMethod  =======
  TYPE, PUBLIC :: WeiMethod
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: sweptarea      !  [-]
    REAL(ReKi)  :: weighting_denominator      !  [-]
  END TYPE WeiMethod
! =======================
! =========  TIDownstream  =======
  TYPE, PUBLIC :: TIDownstream
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TI_downstream_matrix      !  [-]
    INTEGER(IntKi)  :: i      !  [-]
    INTEGER(IntKi)  :: j      !  [-]
    INTEGER(IntKi)  :: k      !  [-]
    INTEGER(IntKi)  :: cross_plane_position_ds      ! the cross plane position which to be investigated in term of the flying time [-]
    INTEGER(IntKi)  :: cross_plane_position_TI      ! the cross plane position which to be investigated in term of the n_x_vector [-]
    INTEGER(IntKi)  :: distance_index      ! the index of the distance in the TI axisymmetric array [-]
    INTEGER(IntKi)  :: counter1      !  [-]
    INTEGER(IntKi)  :: counter2      !  [-]
    INTEGER(IntKi)  :: initial_timestep      !  [-]
    REAL(ReKi)  :: y_axis_turbine      !  [-]
    REAL(ReKi)  :: z_axis_turbine      !  [-]
    REAL(ReKi)  :: distance      ! the distance between one point to the meandered wake center [-]
    REAL(ReKi)  :: TI_downstream_node      ! the TI at a specfic point in the inbestigated cross plane [-]
    REAL(ReKi)  :: TI_node_temp      !  [-]
    REAL(ReKi)  :: TI_node      !  [-]
    REAL(ReKi)  :: TI_accumulation      !  [-]
    REAL(ReKi)  :: TI_apprant_accumulation      !  [-]
    REAL(ReKi)  :: TI_average      ! THE AVERAGE TI OF THE CROSS PLANE [-]
    REAL(ReKi)  :: TI_apprant      ! The TI due to the meadering [-]
    REAL(ReKi)  :: HubHt      !  [-]
    REAL(ReKi)  :: wake_center_y      !  [-]
    REAL(ReKi)  :: wake_center_z      !  [-]
    REAL(ReKi)  :: Rscale      !  [-]
    REAL(ReKi)  :: y      !  [-]
    REAL(ReKi)  :: z      !  [-]
    REAL(ReKi)  :: zero_spacing      !  [-]
    REAL(ReKi)  :: temp1      !  [-]
    REAL(ReKi)  :: temp2      !  [-]
    REAL(ReKi)  :: temp3      !  [-]
  END TYPE TIDownstream
! =======================
! =========  TurbKaimal  =======
  TYPE, PUBLIC :: TurbKaimal
    INTEGER(IntKi)  :: fs      ! sample frequency [-]
    INTEGER(IntKi)  :: temp_n      !  [-]
    INTEGER(IntKi)  :: i      !  [-]
    REAL(ReKi)  :: low_f      ! lower bound of frequency range [-]
    REAL(ReKi)  :: high_f      ! upper bound of frequency range [-]
    REAL(ReKi)  :: lk_facor      ! turbulence length-scale [-]
    REAL(ReKi)  :: STD      ! standard deviation of the turbulence [-]
  END TYPE TurbKaimal
! =======================
! =========  Shinozuka  =======
  TYPE, PUBLIC :: Shinozuka
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: f_syn      ! frequency series [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: t_syn      ! time series [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: phi      ! random phase angle [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: p_k      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: a_k      !  [-]
    INTEGER(IntKi)  :: num_points      ! total number of points [-]
    INTEGER(IntKi)  :: ILo      !  [-]
    INTEGER(IntKi)  :: i      !  [-]
    INTEGER(IntKi)  :: j      !  [-]
    REAL(ReKi)  :: dt      ! time step [-]
    REAL(ReKi)  :: t_min      !  [-]
    REAL(ReKi)  :: t_max      !  [-]
    REAL(ReKi)  :: df      ! frequency step [-]
  END TYPE Shinozuka
! =======================
! =========  smooth_out_wake_data  =======
  TYPE, PUBLIC :: smooth_out_wake_data
    INTEGER(IntKi)  :: length_velocity_array      ! the length of velocity_array [-]
  END TYPE smooth_out_wake_data
! =======================
! =========  SWSV  =======
  TYPE, PUBLIC :: SWSV
    INTEGER(IntKi)  :: p1      !  [-]
    INTEGER(IntKi)  :: p2      !  [-]
    REAL(ReKi)  :: distance      ! the distance from the point to the meandered wake center [-]
    REAL(ReKi)  :: y0      ! wake center position on y axis [-]
    REAL(ReKi)  :: z0      ! wake center position on z axis [-]
    REAL(ReKi)  :: unit      ! single unit length  R/ppR [-]
  END TYPE SWSV
! =======================
! =========  read_upwind_result  =======
  TYPE, PUBLIC :: read_upwind_result
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: upwind_U      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: upwind_wakecenter      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: upwind_meanU      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: upwind_TI      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: upwind_small_TI      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: upwind_smoothWake      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: velocity_aerodyn      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TI_downstream      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: small_scale_TI_downstream      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: smoothed_velocity_array      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: vel_matrix      ! The smoothed out wake velocity matrix for n downwind turbine [-]
  END TYPE read_upwind_result
! =======================
! =========  wake_meandered_center  =======
  TYPE, PUBLIC :: wake_meandered_center
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: wake_width      ! wake width [-]
  END TYPE wake_meandered_center
! =======================
! =========  DWM_turbine_blade  =======
  TYPE, PUBLIC :: DWM_turbine_blade
    INTEGER(IntKi)  :: Aerodyn_turbine_num      !  [-]
    INTEGER(IntKi)  :: Blade_index      !  the index of Aerodyn Blade [-]
    INTEGER(IntKi)  :: Element_index      !  the index of Aerodyn Element [-]
  END TYPE DWM_turbine_blade
! =======================
! =========  DWM_ParameterType  =======
  TYPE, PUBLIC :: DWM_ParameterType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: velocityU      ! the wake velocity profile @ the downstream turbine plane [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: smoothed_wake      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WakePosition      ! meandered wake center [-]
    INTEGER(IntKi)  :: WakePosition_1      ! size of the WakePosition [-]
    INTEGER(IntKi)  :: WakePosition_2      ! size of the WakePosition [-]
    INTEGER(IntKi)  :: smooth_flag      ! Whether or not use the smoothed out upstream wake profile (1-yes, 0-no) [-]
    INTEGER(IntKi)  :: p_p_r      !  [-]
    INTEGER(IntKi)  :: NumWT      ! Number of wind turbines [-]
    INTEGER(IntKi)  :: Tinfluencer      !  [-]
    REAL(ReKi)  :: RotorR      ! Rotor radius [-]
    REAL(ReKi)  :: r_domain      !  [-]
    REAL(ReKi)  :: x_domain      !  [-]
    REAL(ReKi)  :: Uambient      ! The ambient wind velocity [-]
    REAL(ReKi)  :: TI_amb      ! Ambient turbulence intensity [%]
    REAL(ReKi)  :: TI_wake      !  [-]
    REAL(ReKi)  :: hub_height      !  [-]
    REAL(ReKi)  :: length_velocityU      !  [-]
    REAL(ReKi)  :: TurbRefHt      ! The Turbsim wind file reference height [-]
    REAL(ReKi)  :: Wind_file_Mean_u      ! The mean velocity of the first turbine [-]
    REAL(ReKi)  :: Winddir      !  [-]
    REAL(ReKi)  :: air_density      ! air density [-]
    REAL(ReKi)  :: RR      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ElementRad      !  the element node radius [-]
    INTEGER(IntKi)  :: Bnum      !  the number of blade [-]
    INTEGER(IntKi)  :: ElementNum      !  the number of element [-]
    TYPE(read_turbine_position_data)  :: RTPD 
  END TYPE DWM_ParameterType
! =======================
! =========  DWM_OtherStateType  =======
  TYPE, PUBLIC :: DWM_OtherStateType
    REAL(ReKi)  :: position_y      ! the y position of the blade node [-]
    REAL(ReKi)  :: position_z      ! the z position of the blade node [-]
    REAL(ReKi)  :: velocity_wake_mean      !  [-]
    REAL(ReKi)  :: shifted_velocity_Aerodyn      !  [-]
    REAL(ReKi)  :: U_velocity      !  the u component velocity of blade [-]
    REAL(ReKi)  :: V_velocity      !  the v component velocity of blade [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Nforce      !  the normal force [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: blade_dr      !  blade dr [-]
    REAL(ReKi)  :: NacYaw      !  [-]
    REAL(ReKi)  :: TI_original      !  [-]
    TYPE(turbine_average_velocity_data)  :: TAVD 
    TYPE(CVSD)  :: CalVelScale_data 
    TYPE(MeanderData)  :: meandering_data 
    TYPE(WeiMethod)  :: weighting_method 
    TYPE(TIDownstream)  :: TI_downstream_data 
    TYPE(TurbKaimal)  :: Turbulence_KS 
    TYPE(Shinozuka)  :: shinozuka_data 
    TYPE(smooth_out_wake_data)  :: SmoothOut 
    TYPE(SWSV)  :: smooth_wake_shifted_velocity_data 
    TYPE(DWM_Wake_Deficit_Data)  :: DWDD 
    REAL(ReKi)  :: ct_tilde      ! the tilde Ct [-]
    REAL(ReKi)  :: FAST_Time      ! FAST simulation time [-]
    INTEGER(IntKi)  :: SDtimestep = 0      !  [-]
    TYPE(DWM_turbine_blade)  :: DWM_tb 
    TYPE(wake_meandered_center)  :: WMC 
  END TYPE DWM_OtherStateType
! =======================
! =========  DWM_InputType  =======
  TYPE, PUBLIC :: DWM_InputType
    TYPE(read_upwind_result)  :: Upwind_result 
  END TYPE DWM_InputType
! =======================
! =========  DWM_OutputType  =======
  TYPE, PUBLIC :: DWM_OutputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: turbine_thrust_force      !  [N]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: induction_factor      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: r_initial      ! scaled rotor radius [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: U_initial      ! scaled velocity at the rotor [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Mean_FFWS_array      ! Mean velocity of each section on the blade [-]
    REAL(ReKi)  :: Mean_FFWS      ! Mean (total) wind speed at the hub height [m/s]
    REAL(ReKi)  :: TI      ! the turbulence intensity of the turbine [-]
    REAL(ReKi)  :: TI_downstream      ! the TI of a downstream turbine before normalization [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: wake_u      ! wake velocity [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: wake_position      ! wake center position [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: smoothed_velocity_array      ! smoothed out upstream axisymetric wake profile [-]
    REAL(ReKi)  :: AtmUscale      ! atmospheric velocity scale before introducing TI [-]
    REAL(ReKi)  :: du_dz_ABL      ! atmosperic shear gradient [-]
    REAL(ReKi)  :: total_SDgenpwr = 0.0      !  [-]
    REAL(ReKi)  :: mean_SDgenpwr      !  [-]
    REAL(ReKi)  :: avg_ct      ! average Ct over the rotor [-]
  END TYPE DWM_OutputType
! =======================
! =========  DWM_ContinuousStateType  =======
  TYPE, PUBLIC :: DWM_ContinuousStateType
    REAL(ReKi)  :: dummy      !  [-]
  END TYPE DWM_ContinuousStateType
! =======================
! =========  DWM_DiscreteStateType  =======
  TYPE, PUBLIC :: DWM_DiscreteStateType
    REAL(ReKi)  :: dummy      !  [-]
  END TYPE DWM_DiscreteStateType
! =======================
! =========  DWM_ConstraintStateType  =======
  TYPE, PUBLIC :: DWM_ConstraintStateType
    REAL(ReKi)  :: dummy      !  [-]
  END TYPE DWM_ConstraintStateType
! =======================
! =========  DWM_InitInputType  =======
  TYPE, PUBLIC :: DWM_InitInputType
    REAL(ReKi)  :: dummy      !  [-]
    CHARACTER(1024)  :: WindFileName      ! Name of the wind file to use [-]
    REAL(ReKi)  :: ReferenceHeight      ! Hub height of the turbine [meters]
    REAL(ReKi)  :: Width      ! Width of the wind field to use [meters]
    INTEGER(IntKi)  :: WindFileType = 0      ! Type of windfile [-]
  END TYPE DWM_InitInputType
! =======================
! =========  DWM_InitOutputType  =======
  TYPE, PUBLIC :: DWM_InitOutputType
    REAL(ReKi)  :: dummy      !  [-]
  END TYPE DWM_InitOutputType
! =======================
CONTAINS
 SUBROUTINE DWM_Copycvsd( SrccvsdData, DstcvsdData, CtrlCode, ErrStat, ErrMsg )
   TYPE(cvsd), INTENT(INOUT) :: SrccvsdData
   TYPE(cvsd), INTENT(INOUT) :: DstcvsdData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstcvsdData%counter = SrccvsdData%counter
   DstcvsdData%Denominator = SrccvsdData%Denominator
   DstcvsdData%Numerator = SrccvsdData%Numerator
 END SUBROUTINE DWM_Copycvsd

 SUBROUTINE DWM_Destroycvsd( cvsdData, ErrStat, ErrMsg )
  TYPE(cvsd), INTENT(INOUT) :: cvsdData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE DWM_Destroycvsd

 SUBROUTINE DWM_Packcvsd( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(cvsd),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! counter
  Re_BufSz   = Re_BufSz   + 1  ! Denominator
  Re_BufSz   = Re_BufSz   + 1  ! Numerator
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%counter )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Denominator )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Numerator )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE DWM_Packcvsd

 SUBROUTINE DWM_UnPackcvsd( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(cvsd), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%counter = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Denominator = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Numerator = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE DWM_UnPackcvsd

 SUBROUTINE DWM_Copyturbine_average_velocity_data( Srcturbine_average_velocity_dataData, Dstturbine_average_velocity_dataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(turbine_average_velocity_data), INTENT(INOUT) :: Srcturbine_average_velocity_dataData
   TYPE(turbine_average_velocity_data), INTENT(INOUT) :: Dstturbine_average_velocity_dataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(Srcturbine_average_velocity_dataData%average_velocity_array_temp)) THEN
   i1_l = LBOUND(Srcturbine_average_velocity_dataData%average_velocity_array_temp,1)
   i1_u = UBOUND(Srcturbine_average_velocity_dataData%average_velocity_array_temp,1)
   IF (.NOT. ALLOCATED(Dstturbine_average_velocity_dataData%average_velocity_array_temp)) THEN 
      ALLOCATE(Dstturbine_average_velocity_dataData%average_velocity_array_temp(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyturbine_average_velocity_data: Error allocating Dstturbine_average_velocity_dataData%average_velocity_array_temp.'
         RETURN
      END IF
   END IF
   Dstturbine_average_velocity_dataData%average_velocity_array_temp = Srcturbine_average_velocity_dataData%average_velocity_array_temp
ENDIF
IF (ALLOCATED(Srcturbine_average_velocity_dataData%average_velocity_array)) THEN
   i1_l = LBOUND(Srcturbine_average_velocity_dataData%average_velocity_array,1)
   i1_u = UBOUND(Srcturbine_average_velocity_dataData%average_velocity_array,1)
   IF (.NOT. ALLOCATED(Dstturbine_average_velocity_dataData%average_velocity_array)) THEN 
      ALLOCATE(Dstturbine_average_velocity_dataData%average_velocity_array(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyturbine_average_velocity_data: Error allocating Dstturbine_average_velocity_dataData%average_velocity_array.'
         RETURN
      END IF
   END IF
   Dstturbine_average_velocity_dataData%average_velocity_array = Srcturbine_average_velocity_dataData%average_velocity_array
ENDIF
IF (ALLOCATED(Srcturbine_average_velocity_dataData%swept_area)) THEN
   i1_l = LBOUND(Srcturbine_average_velocity_dataData%swept_area,1)
   i1_u = UBOUND(Srcturbine_average_velocity_dataData%swept_area,1)
   IF (.NOT. ALLOCATED(Dstturbine_average_velocity_dataData%swept_area)) THEN 
      ALLOCATE(Dstturbine_average_velocity_dataData%swept_area(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyturbine_average_velocity_data: Error allocating Dstturbine_average_velocity_dataData%swept_area.'
         RETURN
      END IF
   END IF
   Dstturbine_average_velocity_dataData%swept_area = Srcturbine_average_velocity_dataData%swept_area
ENDIF
   Dstturbine_average_velocity_dataData%time_step_velocity = Srcturbine_average_velocity_dataData%time_step_velocity
IF (ALLOCATED(Srcturbine_average_velocity_dataData%time_step_velocity_array)) THEN
   i1_l = LBOUND(Srcturbine_average_velocity_dataData%time_step_velocity_array,1)
   i1_u = UBOUND(Srcturbine_average_velocity_dataData%time_step_velocity_array,1)
   IF (.NOT. ALLOCATED(Dstturbine_average_velocity_dataData%time_step_velocity_array)) THEN 
      ALLOCATE(Dstturbine_average_velocity_dataData%time_step_velocity_array(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyturbine_average_velocity_data: Error allocating Dstturbine_average_velocity_dataData%time_step_velocity_array.'
         RETURN
      END IF
   END IF
   Dstturbine_average_velocity_dataData%time_step_velocity_array = Srcturbine_average_velocity_dataData%time_step_velocity_array
ENDIF
   Dstturbine_average_velocity_dataData%time_step_pass_velocity = Srcturbine_average_velocity_dataData%time_step_pass_velocity
   Dstturbine_average_velocity_dataData%time_step_force = Srcturbine_average_velocity_dataData%time_step_force
 END SUBROUTINE DWM_Copyturbine_average_velocity_data

 SUBROUTINE DWM_Destroyturbine_average_velocity_data( turbine_average_velocity_dataData, ErrStat, ErrMsg )
  TYPE(turbine_average_velocity_data), INTENT(INOUT) :: turbine_average_velocity_dataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(turbine_average_velocity_dataData%average_velocity_array_temp)) THEN
   DEALLOCATE(turbine_average_velocity_dataData%average_velocity_array_temp)
ENDIF
IF (ALLOCATED(turbine_average_velocity_dataData%average_velocity_array)) THEN
   DEALLOCATE(turbine_average_velocity_dataData%average_velocity_array)
ENDIF
IF (ALLOCATED(turbine_average_velocity_dataData%swept_area)) THEN
   DEALLOCATE(turbine_average_velocity_dataData%swept_area)
ENDIF
IF (ALLOCATED(turbine_average_velocity_dataData%time_step_velocity_array)) THEN
   DEALLOCATE(turbine_average_velocity_dataData%time_step_velocity_array)
ENDIF
 END SUBROUTINE DWM_Destroyturbine_average_velocity_data

 SUBROUTINE DWM_Packturbine_average_velocity_data( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(turbine_average_velocity_data),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%average_velocity_array_temp )  ! average_velocity_array_temp 
  Re_BufSz    = Re_BufSz    + SIZE( InData%average_velocity_array )  ! average_velocity_array 
  Re_BufSz    = Re_BufSz    + SIZE( InData%swept_area )  ! swept_area 
  Int_BufSz  = Int_BufSz  + 1  ! time_step_velocity
  Int_BufSz   = Int_BufSz   + SIZE( InData%time_step_velocity_array )  ! time_step_velocity_array 
  Int_BufSz  = Int_BufSz  + 1  ! time_step_pass_velocity
  Int_BufSz  = Int_BufSz  + 1  ! time_step_force
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%average_velocity_array_temp) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%average_velocity_array_temp))-1 ) =  PACK(InData%average_velocity_array_temp ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%average_velocity_array_temp)
  ENDIF
  IF ( ALLOCATED(InData%average_velocity_array) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%average_velocity_array))-1 ) =  PACK(InData%average_velocity_array ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%average_velocity_array)
  ENDIF
  IF ( ALLOCATED(InData%swept_area) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%swept_area))-1 ) =  PACK(InData%swept_area ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%swept_area)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%time_step_velocity )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%time_step_velocity_array) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%time_step_velocity_array))-1 ) = PACK(InData%time_step_velocity_array ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%time_step_velocity_array)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%time_step_pass_velocity )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%time_step_force )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE DWM_Packturbine_average_velocity_data

 SUBROUTINE DWM_UnPackturbine_average_velocity_data( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(turbine_average_velocity_data), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%average_velocity_array_temp) ) THEN
  ALLOCATE(mask1(SIZE(OutData%average_velocity_array_temp,1))); mask1 = .TRUE.
    OutData%average_velocity_array_temp = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%average_velocity_array_temp))-1 ),mask1,OutData%average_velocity_array_temp)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%average_velocity_array_temp)
  ENDIF
  IF ( ALLOCATED(OutData%average_velocity_array) ) THEN
  ALLOCATE(mask1(SIZE(OutData%average_velocity_array,1))); mask1 = .TRUE.
    OutData%average_velocity_array = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%average_velocity_array))-1 ),mask1,OutData%average_velocity_array)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%average_velocity_array)
  ENDIF
  IF ( ALLOCATED(OutData%swept_area) ) THEN
  ALLOCATE(mask1(SIZE(OutData%swept_area,1))); mask1 = .TRUE.
    OutData%swept_area = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%swept_area))-1 ),mask1,OutData%swept_area)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%swept_area)
  ENDIF
  OutData%time_step_velocity = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%time_step_velocity_array) ) THEN
  ALLOCATE(mask1(SIZE(OutData%time_step_velocity_array,1))); mask1 = .TRUE.
    OutData%time_step_velocity_array = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%time_step_velocity_array))-1 ),mask1,OutData%time_step_velocity_array)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%time_step_velocity_array)
  ENDIF
  OutData%time_step_pass_velocity = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%time_step_force = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE DWM_UnPackturbine_average_velocity_data

 SUBROUTINE DWM_Copywake_deficit_data( Srcwake_deficit_dataData, Dstwake_deficit_dataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(dwm_wake_deficit_data), INTENT(INOUT) :: Srcwake_deficit_dataData
   TYPE(dwm_wake_deficit_data), INTENT(INOUT) :: Dstwake_deficit_dataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   Dstwake_deficit_dataData%np_x = Srcwake_deficit_dataData%np_x
   Dstwake_deficit_dataData%X_length = Srcwake_deficit_dataData%X_length
IF (ALLOCATED(Srcwake_deficit_dataData%Turb_Stress_DWM)) THEN
   i1_l = LBOUND(Srcwake_deficit_dataData%Turb_Stress_DWM,1)
   i1_u = UBOUND(Srcwake_deficit_dataData%Turb_Stress_DWM,1)
   i2_l = LBOUND(Srcwake_deficit_dataData%Turb_Stress_DWM,2)
   i2_u = UBOUND(Srcwake_deficit_dataData%Turb_Stress_DWM,2)
   IF (.NOT. ALLOCATED(Dstwake_deficit_dataData%Turb_Stress_DWM)) THEN 
      ALLOCATE(Dstwake_deficit_dataData%Turb_Stress_DWM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copywake_deficit_data: Error allocating Dstwake_deficit_dataData%Turb_Stress_DWM.'
         RETURN
      END IF
   END IF
   Dstwake_deficit_dataData%Turb_Stress_DWM = Srcwake_deficit_dataData%Turb_Stress_DWM
ENDIF
   Dstwake_deficit_dataData%n_x_vector = Srcwake_deficit_dataData%n_x_vector
   Dstwake_deficit_dataData%n_r_vector = Srcwake_deficit_dataData%n_r_vector
   Dstwake_deficit_dataData%ppR = Srcwake_deficit_dataData%ppR
 END SUBROUTINE DWM_Copywake_deficit_data

 SUBROUTINE DWM_Destroywake_deficit_data( wake_deficit_dataData, ErrStat, ErrMsg )
  TYPE(dwm_wake_deficit_data), INTENT(INOUT) :: wake_deficit_dataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(wake_deficit_dataData%Turb_Stress_DWM)) THEN
   DEALLOCATE(wake_deficit_dataData%Turb_Stress_DWM)
ENDIF
 END SUBROUTINE DWM_Destroywake_deficit_data

 SUBROUTINE DWM_Packwake_deficit_data( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(dwm_wake_deficit_data),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! np_x
  Re_BufSz   = Re_BufSz   + 1  ! X_length
  Re_BufSz    = Re_BufSz    + SIZE( InData%Turb_Stress_DWM )  ! Turb_Stress_DWM 
  Int_BufSz  = Int_BufSz  + 1  ! n_x_vector
  Int_BufSz  = Int_BufSz  + 1  ! n_r_vector
  Re_BufSz   = Re_BufSz   + 1  ! ppR
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%np_x )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%X_length )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%Turb_Stress_DWM) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Turb_Stress_DWM))-1 ) =  PACK(InData%Turb_Stress_DWM ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Turb_Stress_DWM)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%n_x_vector )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%n_r_vector )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ppR )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE DWM_Packwake_deficit_data

 SUBROUTINE DWM_UnPackwake_deficit_data( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(dwm_wake_deficit_data), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%np_x = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%X_length = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%Turb_Stress_DWM) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Turb_Stress_DWM,1),SIZE(OutData%Turb_Stress_DWM,2))); mask2 = .TRUE.
    OutData%Turb_Stress_DWM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Turb_Stress_DWM))-1 ),mask2,OutData%Turb_Stress_DWM)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Turb_Stress_DWM)
  ENDIF
  OutData%n_x_vector = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%n_r_vector = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%ppR = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE DWM_UnPackwake_deficit_data

 SUBROUTINE DWM_Copymeanderdata( SrcmeanderdataData, DstmeanderdataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(meanderdata), INTENT(INOUT) :: SrcmeanderdataData
   TYPE(meanderdata), INTENT(INOUT) :: DstmeanderdataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstmeanderdataData%scale_factor = SrcmeanderdataData%scale_factor
   DstmeanderdataData%moving_time = SrcmeanderdataData%moving_time
 END SUBROUTINE DWM_Copymeanderdata

 SUBROUTINE DWM_Destroymeanderdata( meanderdataData, ErrStat, ErrMsg )
  TYPE(meanderdata), INTENT(INOUT) :: meanderdataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE DWM_Destroymeanderdata

 SUBROUTINE DWM_Packmeanderdata( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(meanderdata),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! scale_factor
  Int_BufSz  = Int_BufSz  + 1  ! moving_time
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%scale_factor )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%moving_time )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE DWM_Packmeanderdata

 SUBROUTINE DWM_UnPackmeanderdata( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(meanderdata), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%scale_factor = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%moving_time = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE DWM_UnPackmeanderdata

 SUBROUTINE DWM_Copyread_turbine_position_data( Srcread_turbine_position_dataData, Dstread_turbine_position_dataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(read_turbine_position_data), INTENT(INOUT) :: Srcread_turbine_position_dataData
   TYPE(read_turbine_position_data), INTENT(INOUT) :: Dstread_turbine_position_dataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   Dstread_turbine_position_dataData%SimulationOrder_index = Srcread_turbine_position_dataData%SimulationOrder_index
IF (ALLOCATED(Srcread_turbine_position_dataData%Turbine_sort_order)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%Turbine_sort_order,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%Turbine_sort_order,1)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%Turbine_sort_order)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%Turbine_sort_order(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%Turbine_sort_order.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%Turbine_sort_order = Srcread_turbine_position_dataData%Turbine_sort_order
ENDIF
   Dstread_turbine_position_dataData%WT_index = Srcread_turbine_position_dataData%WT_index
IF (ALLOCATED(Srcread_turbine_position_dataData%TurbineInfluenceData)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%TurbineInfluenceData,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%TurbineInfluenceData,1)
   i2_l = LBOUND(Srcread_turbine_position_dataData%TurbineInfluenceData,2)
   i2_u = UBOUND(Srcread_turbine_position_dataData%TurbineInfluenceData,2)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%TurbineInfluenceData)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%TurbineInfluenceData(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%TurbineInfluenceData.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%TurbineInfluenceData = Srcread_turbine_position_dataData%TurbineInfluenceData
ENDIF
IF (ALLOCATED(Srcread_turbine_position_dataData%upwind_turbine_index)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%upwind_turbine_index,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%upwind_turbine_index,1)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%upwind_turbine_index)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%upwind_turbine_index(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%upwind_turbine_index.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%upwind_turbine_index = Srcread_turbine_position_dataData%upwind_turbine_index
ENDIF
IF (ALLOCATED(Srcread_turbine_position_dataData%downwind_turbine_index)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%downwind_turbine_index,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%downwind_turbine_index,1)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%downwind_turbine_index)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%downwind_turbine_index(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%downwind_turbine_index.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%downwind_turbine_index = Srcread_turbine_position_dataData%downwind_turbine_index
ENDIF
   Dstread_turbine_position_dataData%upwindturbine_number = Srcread_turbine_position_dataData%upwindturbine_number
   Dstread_turbine_position_dataData%downwindturbine_number = Srcread_turbine_position_dataData%downwindturbine_number
IF (ALLOCATED(Srcread_turbine_position_dataData%turbine_windorigin_length)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%turbine_windorigin_length,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%turbine_windorigin_length,1)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%turbine_windorigin_length)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%turbine_windorigin_length(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%turbine_windorigin_length.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%turbine_windorigin_length = Srcread_turbine_position_dataData%turbine_windorigin_length
ENDIF
IF (ALLOCATED(Srcread_turbine_position_dataData%upwind_turbine_projected_distance)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%upwind_turbine_projected_distance,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%upwind_turbine_projected_distance,1)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%upwind_turbine_projected_distance)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%upwind_turbine_projected_distance(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%upwind_turbine_projected_distance.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%upwind_turbine_projected_distance = Srcread_turbine_position_dataData%upwind_turbine_projected_distance
ENDIF
IF (ALLOCATED(Srcread_turbine_position_dataData%downwind_turbine_projected_distance)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%downwind_turbine_projected_distance,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%downwind_turbine_projected_distance,1)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%downwind_turbine_projected_distance)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%downwind_turbine_projected_distance(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%downwind_turbine_projected_distance.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%downwind_turbine_projected_distance = Srcread_turbine_position_dataData%downwind_turbine_projected_distance
ENDIF
IF (ALLOCATED(Srcread_turbine_position_dataData%turbine_angle)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%turbine_angle,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%turbine_angle,1)
   i2_l = LBOUND(Srcread_turbine_position_dataData%turbine_angle,2)
   i2_u = UBOUND(Srcread_turbine_position_dataData%turbine_angle,2)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%turbine_angle)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%turbine_angle(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%turbine_angle.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%turbine_angle = Srcread_turbine_position_dataData%turbine_angle
ENDIF
IF (ALLOCATED(Srcread_turbine_position_dataData%upwind_align_angle)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%upwind_align_angle,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%upwind_align_angle,1)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%upwind_align_angle)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%upwind_align_angle(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%upwind_align_angle.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%upwind_align_angle = Srcread_turbine_position_dataData%upwind_align_angle
ENDIF
IF (ALLOCATED(Srcread_turbine_position_dataData%downwind_align_angle)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%downwind_align_angle,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%downwind_align_angle,1)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%downwind_align_angle)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%downwind_align_angle(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%downwind_align_angle.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%downwind_align_angle = Srcread_turbine_position_dataData%downwind_align_angle
ENDIF
IF (ALLOCATED(Srcread_turbine_position_dataData%upwind_turbine_Xcoor)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%upwind_turbine_Xcoor,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%upwind_turbine_Xcoor,1)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%upwind_turbine_Xcoor)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%upwind_turbine_Xcoor(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%upwind_turbine_Xcoor.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%upwind_turbine_Xcoor = Srcread_turbine_position_dataData%upwind_turbine_Xcoor
ENDIF
IF (ALLOCATED(Srcread_turbine_position_dataData%upwind_turbine_Ycoor)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%upwind_turbine_Ycoor,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%upwind_turbine_Ycoor,1)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%upwind_turbine_Ycoor)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%upwind_turbine_Ycoor(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%upwind_turbine_Ycoor.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%upwind_turbine_Ycoor = Srcread_turbine_position_dataData%upwind_turbine_Ycoor
ENDIF
IF (ALLOCATED(Srcread_turbine_position_dataData%wind_farm_Xcoor)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%wind_farm_Xcoor,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%wind_farm_Xcoor,1)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%wind_farm_Xcoor)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%wind_farm_Xcoor(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%wind_farm_Xcoor.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%wind_farm_Xcoor = Srcread_turbine_position_dataData%wind_farm_Xcoor
ENDIF
IF (ALLOCATED(Srcread_turbine_position_dataData%wind_farm_Ycoor)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%wind_farm_Ycoor,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%wind_farm_Ycoor,1)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%wind_farm_Ycoor)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%wind_farm_Ycoor(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%wind_farm_Ycoor.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%wind_farm_Ycoor = Srcread_turbine_position_dataData%wind_farm_Ycoor
ENDIF
IF (ALLOCATED(Srcread_turbine_position_dataData%downwind_turbine_Xcoor)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%downwind_turbine_Xcoor,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%downwind_turbine_Xcoor,1)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%downwind_turbine_Xcoor)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%downwind_turbine_Xcoor(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%downwind_turbine_Xcoor.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%downwind_turbine_Xcoor = Srcread_turbine_position_dataData%downwind_turbine_Xcoor
ENDIF
IF (ALLOCATED(Srcread_turbine_position_dataData%downwind_turbine_Ycoor)) THEN
   i1_l = LBOUND(Srcread_turbine_position_dataData%downwind_turbine_Ycoor,1)
   i1_u = UBOUND(Srcread_turbine_position_dataData%downwind_turbine_Ycoor,1)
   IF (.NOT. ALLOCATED(Dstread_turbine_position_dataData%downwind_turbine_Ycoor)) THEN 
      ALLOCATE(Dstread_turbine_position_dataData%downwind_turbine_Ycoor(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_turbine_position_data: Error allocating Dstread_turbine_position_dataData%downwind_turbine_Ycoor.'
         RETURN
      END IF
   END IF
   Dstread_turbine_position_dataData%downwind_turbine_Ycoor = Srcread_turbine_position_dataData%downwind_turbine_Ycoor
ENDIF
 END SUBROUTINE DWM_Copyread_turbine_position_data

 SUBROUTINE DWM_Destroyread_turbine_position_data( read_turbine_position_dataData, ErrStat, ErrMsg )
  TYPE(read_turbine_position_data), INTENT(INOUT) :: read_turbine_position_dataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(read_turbine_position_dataData%Turbine_sort_order)) THEN
   DEALLOCATE(read_turbine_position_dataData%Turbine_sort_order)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%TurbineInfluenceData)) THEN
   DEALLOCATE(read_turbine_position_dataData%TurbineInfluenceData)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%upwind_turbine_index)) THEN
   DEALLOCATE(read_turbine_position_dataData%upwind_turbine_index)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%downwind_turbine_index)) THEN
   DEALLOCATE(read_turbine_position_dataData%downwind_turbine_index)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%turbine_windorigin_length)) THEN
   DEALLOCATE(read_turbine_position_dataData%turbine_windorigin_length)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%upwind_turbine_projected_distance)) THEN
   DEALLOCATE(read_turbine_position_dataData%upwind_turbine_projected_distance)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%downwind_turbine_projected_distance)) THEN
   DEALLOCATE(read_turbine_position_dataData%downwind_turbine_projected_distance)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%turbine_angle)) THEN
   DEALLOCATE(read_turbine_position_dataData%turbine_angle)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%upwind_align_angle)) THEN
   DEALLOCATE(read_turbine_position_dataData%upwind_align_angle)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%downwind_align_angle)) THEN
   DEALLOCATE(read_turbine_position_dataData%downwind_align_angle)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%upwind_turbine_Xcoor)) THEN
   DEALLOCATE(read_turbine_position_dataData%upwind_turbine_Xcoor)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%upwind_turbine_Ycoor)) THEN
   DEALLOCATE(read_turbine_position_dataData%upwind_turbine_Ycoor)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%wind_farm_Xcoor)) THEN
   DEALLOCATE(read_turbine_position_dataData%wind_farm_Xcoor)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%wind_farm_Ycoor)) THEN
   DEALLOCATE(read_turbine_position_dataData%wind_farm_Ycoor)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%downwind_turbine_Xcoor)) THEN
   DEALLOCATE(read_turbine_position_dataData%downwind_turbine_Xcoor)
ENDIF
IF (ALLOCATED(read_turbine_position_dataData%downwind_turbine_Ycoor)) THEN
   DEALLOCATE(read_turbine_position_dataData%downwind_turbine_Ycoor)
ENDIF
 END SUBROUTINE DWM_Destroyread_turbine_position_data

 SUBROUTINE DWM_Packread_turbine_position_data( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(read_turbine_position_data),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! SimulationOrder_index
  Int_BufSz   = Int_BufSz   + SIZE( InData%Turbine_sort_order )  ! Turbine_sort_order 
  Int_BufSz  = Int_BufSz  + 1  ! WT_index
  Int_BufSz   = Int_BufSz   + SIZE( InData%TurbineInfluenceData )  ! TurbineInfluenceData 
  Int_BufSz   = Int_BufSz   + SIZE( InData%upwind_turbine_index )  ! upwind_turbine_index 
  Int_BufSz   = Int_BufSz   + SIZE( InData%downwind_turbine_index )  ! downwind_turbine_index 
  Int_BufSz  = Int_BufSz  + 1  ! upwindturbine_number
  Int_BufSz  = Int_BufSz  + 1  ! downwindturbine_number
  Re_BufSz    = Re_BufSz    + SIZE( InData%turbine_windorigin_length )  ! turbine_windorigin_length 
  Re_BufSz    = Re_BufSz    + SIZE( InData%upwind_turbine_projected_distance )  ! upwind_turbine_projected_distance 
  Re_BufSz    = Re_BufSz    + SIZE( InData%downwind_turbine_projected_distance )  ! downwind_turbine_projected_distance 
  Re_BufSz    = Re_BufSz    + SIZE( InData%turbine_angle )  ! turbine_angle 
  Re_BufSz    = Re_BufSz    + SIZE( InData%upwind_align_angle )  ! upwind_align_angle 
  Re_BufSz    = Re_BufSz    + SIZE( InData%downwind_align_angle )  ! downwind_align_angle 
  Re_BufSz    = Re_BufSz    + SIZE( InData%upwind_turbine_Xcoor )  ! upwind_turbine_Xcoor 
  Re_BufSz    = Re_BufSz    + SIZE( InData%upwind_turbine_Ycoor )  ! upwind_turbine_Ycoor 
  Re_BufSz    = Re_BufSz    + SIZE( InData%wind_farm_Xcoor )  ! wind_farm_Xcoor 
  Re_BufSz    = Re_BufSz    + SIZE( InData%wind_farm_Ycoor )  ! wind_farm_Ycoor 
  Re_BufSz    = Re_BufSz    + SIZE( InData%downwind_turbine_Xcoor )  ! downwind_turbine_Xcoor 
  Re_BufSz    = Re_BufSz    + SIZE( InData%downwind_turbine_Ycoor )  ! downwind_turbine_Ycoor 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%SimulationOrder_index )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Turbine_sort_order) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Turbine_sort_order))-1 ) = PACK(InData%Turbine_sort_order ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Turbine_sort_order)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%WT_index )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%TurbineInfluenceData) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%TurbineInfluenceData))-1 ) = PACK(InData%TurbineInfluenceData ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%TurbineInfluenceData)
  ENDIF
  IF ( ALLOCATED(InData%upwind_turbine_index) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%upwind_turbine_index))-1 ) = PACK(InData%upwind_turbine_index ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%upwind_turbine_index)
  ENDIF
  IF ( ALLOCATED(InData%downwind_turbine_index) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%downwind_turbine_index))-1 ) = PACK(InData%downwind_turbine_index ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%downwind_turbine_index)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%upwindturbine_number )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%downwindturbine_number )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%turbine_windorigin_length) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%turbine_windorigin_length))-1 ) =  PACK(InData%turbine_windorigin_length ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%turbine_windorigin_length)
  ENDIF
  IF ( ALLOCATED(InData%upwind_turbine_projected_distance) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%upwind_turbine_projected_distance))-1 ) =  PACK(InData%upwind_turbine_projected_distance ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%upwind_turbine_projected_distance)
  ENDIF
  IF ( ALLOCATED(InData%downwind_turbine_projected_distance) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%downwind_turbine_projected_distance))-1 ) =  PACK(InData%downwind_turbine_projected_distance ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%downwind_turbine_projected_distance)
  ENDIF
  IF ( ALLOCATED(InData%turbine_angle) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%turbine_angle))-1 ) =  PACK(InData%turbine_angle ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%turbine_angle)
  ENDIF
  IF ( ALLOCATED(InData%upwind_align_angle) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%upwind_align_angle))-1 ) =  PACK(InData%upwind_align_angle ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%upwind_align_angle)
  ENDIF
  IF ( ALLOCATED(InData%downwind_align_angle) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%downwind_align_angle))-1 ) =  PACK(InData%downwind_align_angle ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%downwind_align_angle)
  ENDIF
  IF ( ALLOCATED(InData%upwind_turbine_Xcoor) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%upwind_turbine_Xcoor))-1 ) =  PACK(InData%upwind_turbine_Xcoor ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%upwind_turbine_Xcoor)
  ENDIF
  IF ( ALLOCATED(InData%upwind_turbine_Ycoor) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%upwind_turbine_Ycoor))-1 ) =  PACK(InData%upwind_turbine_Ycoor ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%upwind_turbine_Ycoor)
  ENDIF
  IF ( ALLOCATED(InData%wind_farm_Xcoor) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%wind_farm_Xcoor))-1 ) =  PACK(InData%wind_farm_Xcoor ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%wind_farm_Xcoor)
  ENDIF
  IF ( ALLOCATED(InData%wind_farm_Ycoor) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%wind_farm_Ycoor))-1 ) =  PACK(InData%wind_farm_Ycoor ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%wind_farm_Ycoor)
  ENDIF
  IF ( ALLOCATED(InData%downwind_turbine_Xcoor) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%downwind_turbine_Xcoor))-1 ) =  PACK(InData%downwind_turbine_Xcoor ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%downwind_turbine_Xcoor)
  ENDIF
  IF ( ALLOCATED(InData%downwind_turbine_Ycoor) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%downwind_turbine_Ycoor))-1 ) =  PACK(InData%downwind_turbine_Ycoor ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%downwind_turbine_Ycoor)
  ENDIF
 END SUBROUTINE DWM_Packread_turbine_position_data

 SUBROUTINE DWM_UnPackread_turbine_position_data( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(read_turbine_position_data), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%SimulationOrder_index = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Turbine_sort_order) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Turbine_sort_order,1))); mask1 = .TRUE.
    OutData%Turbine_sort_order = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Turbine_sort_order))-1 ),mask1,OutData%Turbine_sort_order)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Turbine_sort_order)
  ENDIF
  OutData%WT_index = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%TurbineInfluenceData) ) THEN
  ALLOCATE(mask2(SIZE(OutData%TurbineInfluenceData,1),SIZE(OutData%TurbineInfluenceData,2))); mask2 = .TRUE.
    OutData%TurbineInfluenceData = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%TurbineInfluenceData))-1 ),mask2,OutData%TurbineInfluenceData)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%TurbineInfluenceData)
  ENDIF
  IF ( ALLOCATED(OutData%upwind_turbine_index) ) THEN
  ALLOCATE(mask1(SIZE(OutData%upwind_turbine_index,1))); mask1 = .TRUE.
    OutData%upwind_turbine_index = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%upwind_turbine_index))-1 ),mask1,OutData%upwind_turbine_index)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%upwind_turbine_index)
  ENDIF
  IF ( ALLOCATED(OutData%downwind_turbine_index) ) THEN
  ALLOCATE(mask1(SIZE(OutData%downwind_turbine_index,1))); mask1 = .TRUE.
    OutData%downwind_turbine_index = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%downwind_turbine_index))-1 ),mask1,OutData%downwind_turbine_index)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%downwind_turbine_index)
  ENDIF
  OutData%upwindturbine_number = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%downwindturbine_number = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%turbine_windorigin_length) ) THEN
  ALLOCATE(mask1(SIZE(OutData%turbine_windorigin_length,1))); mask1 = .TRUE.
    OutData%turbine_windorigin_length = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%turbine_windorigin_length))-1 ),mask1,OutData%turbine_windorigin_length)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%turbine_windorigin_length)
  ENDIF
  IF ( ALLOCATED(OutData%upwind_turbine_projected_distance) ) THEN
  ALLOCATE(mask1(SIZE(OutData%upwind_turbine_projected_distance,1))); mask1 = .TRUE.
    OutData%upwind_turbine_projected_distance = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%upwind_turbine_projected_distance))-1 ),mask1,OutData%upwind_turbine_projected_distance)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%upwind_turbine_projected_distance)
  ENDIF
  IF ( ALLOCATED(OutData%downwind_turbine_projected_distance) ) THEN
  ALLOCATE(mask1(SIZE(OutData%downwind_turbine_projected_distance,1))); mask1 = .TRUE.
    OutData%downwind_turbine_projected_distance = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%downwind_turbine_projected_distance))-1 ),mask1,OutData%downwind_turbine_projected_distance)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%downwind_turbine_projected_distance)
  ENDIF
  IF ( ALLOCATED(OutData%turbine_angle) ) THEN
  ALLOCATE(mask2(SIZE(OutData%turbine_angle,1),SIZE(OutData%turbine_angle,2))); mask2 = .TRUE.
    OutData%turbine_angle = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%turbine_angle))-1 ),mask2,OutData%turbine_angle)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%turbine_angle)
  ENDIF
  IF ( ALLOCATED(OutData%upwind_align_angle) ) THEN
  ALLOCATE(mask1(SIZE(OutData%upwind_align_angle,1))); mask1 = .TRUE.
    OutData%upwind_align_angle = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%upwind_align_angle))-1 ),mask1,OutData%upwind_align_angle)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%upwind_align_angle)
  ENDIF
  IF ( ALLOCATED(OutData%downwind_align_angle) ) THEN
  ALLOCATE(mask1(SIZE(OutData%downwind_align_angle,1))); mask1 = .TRUE.
    OutData%downwind_align_angle = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%downwind_align_angle))-1 ),mask1,OutData%downwind_align_angle)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%downwind_align_angle)
  ENDIF
  IF ( ALLOCATED(OutData%upwind_turbine_Xcoor) ) THEN
  ALLOCATE(mask1(SIZE(OutData%upwind_turbine_Xcoor,1))); mask1 = .TRUE.
    OutData%upwind_turbine_Xcoor = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%upwind_turbine_Xcoor))-1 ),mask1,OutData%upwind_turbine_Xcoor)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%upwind_turbine_Xcoor)
  ENDIF
  IF ( ALLOCATED(OutData%upwind_turbine_Ycoor) ) THEN
  ALLOCATE(mask1(SIZE(OutData%upwind_turbine_Ycoor,1))); mask1 = .TRUE.
    OutData%upwind_turbine_Ycoor = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%upwind_turbine_Ycoor))-1 ),mask1,OutData%upwind_turbine_Ycoor)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%upwind_turbine_Ycoor)
  ENDIF
  IF ( ALLOCATED(OutData%wind_farm_Xcoor) ) THEN
  ALLOCATE(mask1(SIZE(OutData%wind_farm_Xcoor,1))); mask1 = .TRUE.
    OutData%wind_farm_Xcoor = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%wind_farm_Xcoor))-1 ),mask1,OutData%wind_farm_Xcoor)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%wind_farm_Xcoor)
  ENDIF
  IF ( ALLOCATED(OutData%wind_farm_Ycoor) ) THEN
  ALLOCATE(mask1(SIZE(OutData%wind_farm_Ycoor,1))); mask1 = .TRUE.
    OutData%wind_farm_Ycoor = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%wind_farm_Ycoor))-1 ),mask1,OutData%wind_farm_Ycoor)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%wind_farm_Ycoor)
  ENDIF
  IF ( ALLOCATED(OutData%downwind_turbine_Xcoor) ) THEN
  ALLOCATE(mask1(SIZE(OutData%downwind_turbine_Xcoor,1))); mask1 = .TRUE.
    OutData%downwind_turbine_Xcoor = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%downwind_turbine_Xcoor))-1 ),mask1,OutData%downwind_turbine_Xcoor)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%downwind_turbine_Xcoor)
  ENDIF
  IF ( ALLOCATED(OutData%downwind_turbine_Ycoor) ) THEN
  ALLOCATE(mask1(SIZE(OutData%downwind_turbine_Ycoor,1))); mask1 = .TRUE.
    OutData%downwind_turbine_Ycoor = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%downwind_turbine_Ycoor))-1 ),mask1,OutData%downwind_turbine_Ycoor)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%downwind_turbine_Ycoor)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE DWM_UnPackread_turbine_position_data

 SUBROUTINE DWM_Copyweimethod( SrcweimethodData, DstweimethodData, CtrlCode, ErrStat, ErrMsg )
   TYPE(weimethod), INTENT(INOUT) :: SrcweimethodData
   TYPE(weimethod), INTENT(INOUT) :: DstweimethodData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcweimethodData%sweptarea)) THEN
   i1_l = LBOUND(SrcweimethodData%sweptarea,1)
   i1_u = UBOUND(SrcweimethodData%sweptarea,1)
   IF (.NOT. ALLOCATED(DstweimethodData%sweptarea)) THEN 
      ALLOCATE(DstweimethodData%sweptarea(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyweimethod: Error allocating DstweimethodData%sweptarea.'
         RETURN
      END IF
   END IF
   DstweimethodData%sweptarea = SrcweimethodData%sweptarea
ENDIF
   DstweimethodData%weighting_denominator = SrcweimethodData%weighting_denominator
 END SUBROUTINE DWM_Copyweimethod

 SUBROUTINE DWM_Destroyweimethod( weimethodData, ErrStat, ErrMsg )
  TYPE(weimethod), INTENT(INOUT) :: weimethodData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(weimethodData%sweptarea)) THEN
   DEALLOCATE(weimethodData%sweptarea)
ENDIF
 END SUBROUTINE DWM_Destroyweimethod

 SUBROUTINE DWM_Packweimethod( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(weimethod),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%sweptarea )  ! sweptarea 
  Re_BufSz   = Re_BufSz   + 1  ! weighting_denominator
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%sweptarea) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%sweptarea))-1 ) =  PACK(InData%sweptarea ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%sweptarea)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%weighting_denominator )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE DWM_Packweimethod

 SUBROUTINE DWM_UnPackweimethod( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(weimethod), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%sweptarea) ) THEN
  ALLOCATE(mask1(SIZE(OutData%sweptarea,1))); mask1 = .TRUE.
    OutData%sweptarea = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%sweptarea))-1 ),mask1,OutData%sweptarea)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%sweptarea)
  ENDIF
  OutData%weighting_denominator = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE DWM_UnPackweimethod

 SUBROUTINE DWM_Copytidownstream( SrctidownstreamData, DsttidownstreamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(tidownstream), INTENT(INOUT) :: SrctidownstreamData
   TYPE(tidownstream), INTENT(INOUT) :: DsttidownstreamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrctidownstreamData%TI_downstream_matrix)) THEN
   i1_l = LBOUND(SrctidownstreamData%TI_downstream_matrix,1)
   i1_u = UBOUND(SrctidownstreamData%TI_downstream_matrix,1)
   i2_l = LBOUND(SrctidownstreamData%TI_downstream_matrix,2)
   i2_u = UBOUND(SrctidownstreamData%TI_downstream_matrix,2)
   IF (.NOT. ALLOCATED(DsttidownstreamData%TI_downstream_matrix)) THEN 
      ALLOCATE(DsttidownstreamData%TI_downstream_matrix(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copytidownstream: Error allocating DsttidownstreamData%TI_downstream_matrix.'
         RETURN
      END IF
   END IF
   DsttidownstreamData%TI_downstream_matrix = SrctidownstreamData%TI_downstream_matrix
ENDIF
   DsttidownstreamData%i = SrctidownstreamData%i
   DsttidownstreamData%j = SrctidownstreamData%j
   DsttidownstreamData%k = SrctidownstreamData%k
   DsttidownstreamData%cross_plane_position_ds = SrctidownstreamData%cross_plane_position_ds
   DsttidownstreamData%cross_plane_position_TI = SrctidownstreamData%cross_plane_position_TI
   DsttidownstreamData%distance_index = SrctidownstreamData%distance_index
   DsttidownstreamData%counter1 = SrctidownstreamData%counter1
   DsttidownstreamData%counter2 = SrctidownstreamData%counter2
   DsttidownstreamData%initial_timestep = SrctidownstreamData%initial_timestep
   DsttidownstreamData%y_axis_turbine = SrctidownstreamData%y_axis_turbine
   DsttidownstreamData%z_axis_turbine = SrctidownstreamData%z_axis_turbine
   DsttidownstreamData%distance = SrctidownstreamData%distance
   DsttidownstreamData%TI_downstream_node = SrctidownstreamData%TI_downstream_node
   DsttidownstreamData%TI_node_temp = SrctidownstreamData%TI_node_temp
   DsttidownstreamData%TI_node = SrctidownstreamData%TI_node
   DsttidownstreamData%TI_accumulation = SrctidownstreamData%TI_accumulation
   DsttidownstreamData%TI_apprant_accumulation = SrctidownstreamData%TI_apprant_accumulation
   DsttidownstreamData%TI_average = SrctidownstreamData%TI_average
   DsttidownstreamData%TI_apprant = SrctidownstreamData%TI_apprant
   DsttidownstreamData%HubHt = SrctidownstreamData%HubHt
   DsttidownstreamData%wake_center_y = SrctidownstreamData%wake_center_y
   DsttidownstreamData%wake_center_z = SrctidownstreamData%wake_center_z
   DsttidownstreamData%Rscale = SrctidownstreamData%Rscale
   DsttidownstreamData%y = SrctidownstreamData%y
   DsttidownstreamData%z = SrctidownstreamData%z
   DsttidownstreamData%zero_spacing = SrctidownstreamData%zero_spacing
   DsttidownstreamData%temp1 = SrctidownstreamData%temp1
   DsttidownstreamData%temp2 = SrctidownstreamData%temp2
   DsttidownstreamData%temp3 = SrctidownstreamData%temp3
 END SUBROUTINE DWM_Copytidownstream

 SUBROUTINE DWM_Destroytidownstream( tidownstreamData, ErrStat, ErrMsg )
  TYPE(tidownstream), INTENT(INOUT) :: tidownstreamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(tidownstreamData%TI_downstream_matrix)) THEN
   DEALLOCATE(tidownstreamData%TI_downstream_matrix)
ENDIF
 END SUBROUTINE DWM_Destroytidownstream

 SUBROUTINE DWM_Packtidownstream( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(tidownstream),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%TI_downstream_matrix )  ! TI_downstream_matrix 
  Int_BufSz  = Int_BufSz  + 1  ! i
  Int_BufSz  = Int_BufSz  + 1  ! j
  Int_BufSz  = Int_BufSz  + 1  ! k
  Int_BufSz  = Int_BufSz  + 1  ! cross_plane_position_ds
  Int_BufSz  = Int_BufSz  + 1  ! cross_plane_position_TI
  Int_BufSz  = Int_BufSz  + 1  ! distance_index
  Int_BufSz  = Int_BufSz  + 1  ! counter1
  Int_BufSz  = Int_BufSz  + 1  ! counter2
  Int_BufSz  = Int_BufSz  + 1  ! initial_timestep
  Re_BufSz   = Re_BufSz   + 1  ! y_axis_turbine
  Re_BufSz   = Re_BufSz   + 1  ! z_axis_turbine
  Re_BufSz   = Re_BufSz   + 1  ! distance
  Re_BufSz   = Re_BufSz   + 1  ! TI_downstream_node
  Re_BufSz   = Re_BufSz   + 1  ! TI_node_temp
  Re_BufSz   = Re_BufSz   + 1  ! TI_node
  Re_BufSz   = Re_BufSz   + 1  ! TI_accumulation
  Re_BufSz   = Re_BufSz   + 1  ! TI_apprant_accumulation
  Re_BufSz   = Re_BufSz   + 1  ! TI_average
  Re_BufSz   = Re_BufSz   + 1  ! TI_apprant
  Re_BufSz   = Re_BufSz   + 1  ! HubHt
  Re_BufSz   = Re_BufSz   + 1  ! wake_center_y
  Re_BufSz   = Re_BufSz   + 1  ! wake_center_z
  Re_BufSz   = Re_BufSz   + 1  ! Rscale
  Re_BufSz   = Re_BufSz   + 1  ! y
  Re_BufSz   = Re_BufSz   + 1  ! z
  Re_BufSz   = Re_BufSz   + 1  ! zero_spacing
  Re_BufSz   = Re_BufSz   + 1  ! temp1
  Re_BufSz   = Re_BufSz   + 1  ! temp2
  Re_BufSz   = Re_BufSz   + 1  ! temp3
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%TI_downstream_matrix) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TI_downstream_matrix))-1 ) =  PACK(InData%TI_downstream_matrix ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%TI_downstream_matrix)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%i )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%j )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%k )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%cross_plane_position_ds )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%cross_plane_position_TI )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%distance_index )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%counter1 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%counter2 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%initial_timestep )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%y_axis_turbine )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%z_axis_turbine )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%distance )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TI_downstream_node )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TI_node_temp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TI_node )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TI_accumulation )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TI_apprant_accumulation )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TI_average )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TI_apprant )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HubHt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%wake_center_y )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%wake_center_z )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Rscale )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%y )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%z )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%zero_spacing )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%temp1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%temp2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%temp3 )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE DWM_Packtidownstream

 SUBROUTINE DWM_UnPacktidownstream( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(tidownstream), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%TI_downstream_matrix) ) THEN
  ALLOCATE(mask2(SIZE(OutData%TI_downstream_matrix,1),SIZE(OutData%TI_downstream_matrix,2))); mask2 = .TRUE.
    OutData%TI_downstream_matrix = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TI_downstream_matrix))-1 ),mask2,OutData%TI_downstream_matrix)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%TI_downstream_matrix)
  ENDIF
  OutData%i = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%j = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%k = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%cross_plane_position_ds = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%cross_plane_position_TI = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%distance_index = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%counter1 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%counter2 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%initial_timestep = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%y_axis_turbine = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%z_axis_turbine = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%distance = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TI_downstream_node = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TI_node_temp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TI_node = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TI_accumulation = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TI_apprant_accumulation = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TI_average = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TI_apprant = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HubHt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%wake_center_y = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%wake_center_z = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Rscale = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%y = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%z = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%zero_spacing = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%temp1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%temp2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%temp3 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE DWM_UnPacktidownstream

 SUBROUTINE DWM_Copyturbkaimal( SrcturbkaimalData, DstturbkaimalData, CtrlCode, ErrStat, ErrMsg )
   TYPE(turbkaimal), INTENT(INOUT) :: SrcturbkaimalData
   TYPE(turbkaimal), INTENT(INOUT) :: DstturbkaimalData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstturbkaimalData%fs = SrcturbkaimalData%fs
   DstturbkaimalData%temp_n = SrcturbkaimalData%temp_n
   DstturbkaimalData%i = SrcturbkaimalData%i
   DstturbkaimalData%low_f = SrcturbkaimalData%low_f
   DstturbkaimalData%high_f = SrcturbkaimalData%high_f
   DstturbkaimalData%lk_facor = SrcturbkaimalData%lk_facor
   DstturbkaimalData%STD = SrcturbkaimalData%STD
 END SUBROUTINE DWM_Copyturbkaimal

 SUBROUTINE DWM_Destroyturbkaimal( turbkaimalData, ErrStat, ErrMsg )
  TYPE(turbkaimal), INTENT(INOUT) :: turbkaimalData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE DWM_Destroyturbkaimal

 SUBROUTINE DWM_Packturbkaimal( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(turbkaimal),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! fs
  Int_BufSz  = Int_BufSz  + 1  ! temp_n
  Int_BufSz  = Int_BufSz  + 1  ! i
  Re_BufSz   = Re_BufSz   + 1  ! low_f
  Re_BufSz   = Re_BufSz   + 1  ! high_f
  Re_BufSz   = Re_BufSz   + 1  ! lk_facor
  Re_BufSz   = Re_BufSz   + 1  ! STD
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%fs )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%temp_n )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%i )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%low_f )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%high_f )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%lk_facor )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%STD )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE DWM_Packturbkaimal

 SUBROUTINE DWM_UnPackturbkaimal( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(turbkaimal), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%fs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%temp_n = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%i = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%low_f = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%high_f = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%lk_facor = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%STD = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE DWM_UnPackturbkaimal

 SUBROUTINE DWM_Copyshinozuka( SrcshinozukaData, DstshinozukaData, CtrlCode, ErrStat, ErrMsg )
   TYPE(shinozuka), INTENT(INOUT) :: SrcshinozukaData
   TYPE(shinozuka), INTENT(INOUT) :: DstshinozukaData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcshinozukaData%f_syn)) THEN
   i1_l = LBOUND(SrcshinozukaData%f_syn,1)
   i1_u = UBOUND(SrcshinozukaData%f_syn,1)
   IF (.NOT. ALLOCATED(DstshinozukaData%f_syn)) THEN 
      ALLOCATE(DstshinozukaData%f_syn(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyshinozuka: Error allocating DstshinozukaData%f_syn.'
         RETURN
      END IF
   END IF
   DstshinozukaData%f_syn = SrcshinozukaData%f_syn
ENDIF
IF (ALLOCATED(SrcshinozukaData%t_syn)) THEN
   i1_l = LBOUND(SrcshinozukaData%t_syn,1)
   i1_u = UBOUND(SrcshinozukaData%t_syn,1)
   IF (.NOT. ALLOCATED(DstshinozukaData%t_syn)) THEN 
      ALLOCATE(DstshinozukaData%t_syn(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyshinozuka: Error allocating DstshinozukaData%t_syn.'
         RETURN
      END IF
   END IF
   DstshinozukaData%t_syn = SrcshinozukaData%t_syn
ENDIF
IF (ALLOCATED(SrcshinozukaData%phi)) THEN
   i1_l = LBOUND(SrcshinozukaData%phi,1)
   i1_u = UBOUND(SrcshinozukaData%phi,1)
   IF (.NOT. ALLOCATED(DstshinozukaData%phi)) THEN 
      ALLOCATE(DstshinozukaData%phi(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyshinozuka: Error allocating DstshinozukaData%phi.'
         RETURN
      END IF
   END IF
   DstshinozukaData%phi = SrcshinozukaData%phi
ENDIF
IF (ALLOCATED(SrcshinozukaData%p_k)) THEN
   i1_l = LBOUND(SrcshinozukaData%p_k,1)
   i1_u = UBOUND(SrcshinozukaData%p_k,1)
   IF (.NOT. ALLOCATED(DstshinozukaData%p_k)) THEN 
      ALLOCATE(DstshinozukaData%p_k(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyshinozuka: Error allocating DstshinozukaData%p_k.'
         RETURN
      END IF
   END IF
   DstshinozukaData%p_k = SrcshinozukaData%p_k
ENDIF
IF (ALLOCATED(SrcshinozukaData%a_k)) THEN
   i1_l = LBOUND(SrcshinozukaData%a_k,1)
   i1_u = UBOUND(SrcshinozukaData%a_k,1)
   IF (.NOT. ALLOCATED(DstshinozukaData%a_k)) THEN 
      ALLOCATE(DstshinozukaData%a_k(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyshinozuka: Error allocating DstshinozukaData%a_k.'
         RETURN
      END IF
   END IF
   DstshinozukaData%a_k = SrcshinozukaData%a_k
ENDIF
   DstshinozukaData%num_points = SrcshinozukaData%num_points
   DstshinozukaData%ILo = SrcshinozukaData%ILo
   DstshinozukaData%i = SrcshinozukaData%i
   DstshinozukaData%j = SrcshinozukaData%j
   DstshinozukaData%dt = SrcshinozukaData%dt
   DstshinozukaData%t_min = SrcshinozukaData%t_min
   DstshinozukaData%t_max = SrcshinozukaData%t_max
   DstshinozukaData%df = SrcshinozukaData%df
 END SUBROUTINE DWM_Copyshinozuka

 SUBROUTINE DWM_Destroyshinozuka( shinozukaData, ErrStat, ErrMsg )
  TYPE(shinozuka), INTENT(INOUT) :: shinozukaData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(shinozukaData%f_syn)) THEN
   DEALLOCATE(shinozukaData%f_syn)
ENDIF
IF (ALLOCATED(shinozukaData%t_syn)) THEN
   DEALLOCATE(shinozukaData%t_syn)
ENDIF
IF (ALLOCATED(shinozukaData%phi)) THEN
   DEALLOCATE(shinozukaData%phi)
ENDIF
IF (ALLOCATED(shinozukaData%p_k)) THEN
   DEALLOCATE(shinozukaData%p_k)
ENDIF
IF (ALLOCATED(shinozukaData%a_k)) THEN
   DEALLOCATE(shinozukaData%a_k)
ENDIF
 END SUBROUTINE DWM_Destroyshinozuka

 SUBROUTINE DWM_Packshinozuka( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(shinozuka),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%f_syn )  ! f_syn 
  Re_BufSz    = Re_BufSz    + SIZE( InData%t_syn )  ! t_syn 
  Re_BufSz    = Re_BufSz    + SIZE( InData%phi )  ! phi 
  Re_BufSz    = Re_BufSz    + SIZE( InData%p_k )  ! p_k 
  Re_BufSz    = Re_BufSz    + SIZE( InData%a_k )  ! a_k 
  Int_BufSz  = Int_BufSz  + 1  ! num_points
  Int_BufSz  = Int_BufSz  + 1  ! ILo
  Int_BufSz  = Int_BufSz  + 1  ! i
  Int_BufSz  = Int_BufSz  + 1  ! j
  Re_BufSz   = Re_BufSz   + 1  ! dt
  Re_BufSz   = Re_BufSz   + 1  ! t_min
  Re_BufSz   = Re_BufSz   + 1  ! t_max
  Re_BufSz   = Re_BufSz   + 1  ! df
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%f_syn) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%f_syn))-1 ) =  PACK(InData%f_syn ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%f_syn)
  ENDIF
  IF ( ALLOCATED(InData%t_syn) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%t_syn))-1 ) =  PACK(InData%t_syn ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%t_syn)
  ENDIF
  IF ( ALLOCATED(InData%phi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%phi))-1 ) =  PACK(InData%phi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%phi)
  ENDIF
  IF ( ALLOCATED(InData%p_k) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%p_k))-1 ) =  PACK(InData%p_k ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%p_k)
  ENDIF
  IF ( ALLOCATED(InData%a_k) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%a_k))-1 ) =  PACK(InData%a_k ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%a_k)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%num_points )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%ILo )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%i )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%j )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%dt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%t_min )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%t_max )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%df )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE DWM_Packshinozuka

 SUBROUTINE DWM_UnPackshinozuka( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(shinozuka), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%f_syn) ) THEN
  ALLOCATE(mask1(SIZE(OutData%f_syn,1))); mask1 = .TRUE.
    OutData%f_syn = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%f_syn))-1 ),mask1,OutData%f_syn)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%f_syn)
  ENDIF
  IF ( ALLOCATED(OutData%t_syn) ) THEN
  ALLOCATE(mask1(SIZE(OutData%t_syn,1))); mask1 = .TRUE.
    OutData%t_syn = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%t_syn))-1 ),mask1,OutData%t_syn)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%t_syn)
  ENDIF
  IF ( ALLOCATED(OutData%phi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%phi,1))); mask1 = .TRUE.
    OutData%phi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%phi))-1 ),mask1,OutData%phi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%phi)
  ENDIF
  IF ( ALLOCATED(OutData%p_k) ) THEN
  ALLOCATE(mask1(SIZE(OutData%p_k,1))); mask1 = .TRUE.
    OutData%p_k = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%p_k))-1 ),mask1,OutData%p_k)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%p_k)
  ENDIF
  IF ( ALLOCATED(OutData%a_k) ) THEN
  ALLOCATE(mask1(SIZE(OutData%a_k,1))); mask1 = .TRUE.
    OutData%a_k = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%a_k))-1 ),mask1,OutData%a_k)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%a_k)
  ENDIF
  OutData%num_points = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%ILo = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%i = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%j = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%dt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%t_min = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%t_max = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%df = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE DWM_UnPackshinozuka

 SUBROUTINE DWM_Copysmooth_out_wake_data( Srcsmooth_out_wake_dataData, Dstsmooth_out_wake_dataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(smooth_out_wake_data), INTENT(INOUT) :: Srcsmooth_out_wake_dataData
   TYPE(smooth_out_wake_data), INTENT(INOUT) :: Dstsmooth_out_wake_dataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   Dstsmooth_out_wake_dataData%length_velocity_array = Srcsmooth_out_wake_dataData%length_velocity_array
 END SUBROUTINE DWM_Copysmooth_out_wake_data

 SUBROUTINE DWM_Destroysmooth_out_wake_data( smooth_out_wake_dataData, ErrStat, ErrMsg )
  TYPE(smooth_out_wake_data), INTENT(INOUT) :: smooth_out_wake_dataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE DWM_Destroysmooth_out_wake_data

 SUBROUTINE DWM_Packsmooth_out_wake_data( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(smooth_out_wake_data),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! length_velocity_array
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%length_velocity_array )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE DWM_Packsmooth_out_wake_data

 SUBROUTINE DWM_UnPacksmooth_out_wake_data( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(smooth_out_wake_data), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%length_velocity_array = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE DWM_UnPacksmooth_out_wake_data

 SUBROUTINE DWM_Copyswsv( SrcswsvData, DstswsvData, CtrlCode, ErrStat, ErrMsg )
   TYPE(swsv), INTENT(INOUT) :: SrcswsvData
   TYPE(swsv), INTENT(INOUT) :: DstswsvData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstswsvData%p1 = SrcswsvData%p1
   DstswsvData%p2 = SrcswsvData%p2
   DstswsvData%distance = SrcswsvData%distance
   DstswsvData%y0 = SrcswsvData%y0
   DstswsvData%z0 = SrcswsvData%z0
   DstswsvData%unit = SrcswsvData%unit
 END SUBROUTINE DWM_Copyswsv

 SUBROUTINE DWM_Destroyswsv( swsvData, ErrStat, ErrMsg )
  TYPE(swsv), INTENT(INOUT) :: swsvData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE DWM_Destroyswsv

 SUBROUTINE DWM_Packswsv( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(swsv),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! p1
  Int_BufSz  = Int_BufSz  + 1  ! p2
  Re_BufSz   = Re_BufSz   + 1  ! distance
  Re_BufSz   = Re_BufSz   + 1  ! y0
  Re_BufSz   = Re_BufSz   + 1  ! z0
  Re_BufSz   = Re_BufSz   + 1  ! unit
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%p1 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%p2 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%distance )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%y0 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%z0 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%unit )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE DWM_Packswsv

 SUBROUTINE DWM_UnPackswsv( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(swsv), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%p1 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%p2 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%distance = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%y0 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%z0 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%unit = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE DWM_UnPackswsv

 SUBROUTINE DWM_Copyread_upwind_result( Srcread_upwind_resultData, Dstread_upwind_resultData, CtrlCode, ErrStat, ErrMsg )
   TYPE(read_upwind_result), INTENT(INOUT) :: Srcread_upwind_resultData
   TYPE(read_upwind_result), INTENT(INOUT) :: Dstread_upwind_resultData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(Srcread_upwind_resultData%upwind_U)) THEN
   i1_l = LBOUND(Srcread_upwind_resultData%upwind_U,1)
   i1_u = UBOUND(Srcread_upwind_resultData%upwind_U,1)
   i2_l = LBOUND(Srcread_upwind_resultData%upwind_U,2)
   i2_u = UBOUND(Srcread_upwind_resultData%upwind_U,2)
   IF (.NOT. ALLOCATED(Dstread_upwind_resultData%upwind_U)) THEN 
      ALLOCATE(Dstread_upwind_resultData%upwind_U(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_upwind_result: Error allocating Dstread_upwind_resultData%upwind_U.'
         RETURN
      END IF
   END IF
   Dstread_upwind_resultData%upwind_U = Srcread_upwind_resultData%upwind_U
ENDIF
IF (ALLOCATED(Srcread_upwind_resultData%upwind_wakecenter)) THEN
   i1_l = LBOUND(Srcread_upwind_resultData%upwind_wakecenter,1)
   i1_u = UBOUND(Srcread_upwind_resultData%upwind_wakecenter,1)
   i2_l = LBOUND(Srcread_upwind_resultData%upwind_wakecenter,2)
   i2_u = UBOUND(Srcread_upwind_resultData%upwind_wakecenter,2)
   i3_l = LBOUND(Srcread_upwind_resultData%upwind_wakecenter,3)
   i3_u = UBOUND(Srcread_upwind_resultData%upwind_wakecenter,3)
   i4_l = LBOUND(Srcread_upwind_resultData%upwind_wakecenter,4)
   i4_u = UBOUND(Srcread_upwind_resultData%upwind_wakecenter,4)
   IF (.NOT. ALLOCATED(Dstread_upwind_resultData%upwind_wakecenter)) THEN 
      ALLOCATE(Dstread_upwind_resultData%upwind_wakecenter(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_upwind_result: Error allocating Dstread_upwind_resultData%upwind_wakecenter.'
         RETURN
      END IF
   END IF
   Dstread_upwind_resultData%upwind_wakecenter = Srcread_upwind_resultData%upwind_wakecenter
ENDIF
IF (ALLOCATED(Srcread_upwind_resultData%upwind_meanU)) THEN
   i1_l = LBOUND(Srcread_upwind_resultData%upwind_meanU,1)
   i1_u = UBOUND(Srcread_upwind_resultData%upwind_meanU,1)
   IF (.NOT. ALLOCATED(Dstread_upwind_resultData%upwind_meanU)) THEN 
      ALLOCATE(Dstread_upwind_resultData%upwind_meanU(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_upwind_result: Error allocating Dstread_upwind_resultData%upwind_meanU.'
         RETURN
      END IF
   END IF
   Dstread_upwind_resultData%upwind_meanU = Srcread_upwind_resultData%upwind_meanU
ENDIF
IF (ALLOCATED(Srcread_upwind_resultData%upwind_TI)) THEN
   i1_l = LBOUND(Srcread_upwind_resultData%upwind_TI,1)
   i1_u = UBOUND(Srcread_upwind_resultData%upwind_TI,1)
   IF (.NOT. ALLOCATED(Dstread_upwind_resultData%upwind_TI)) THEN 
      ALLOCATE(Dstread_upwind_resultData%upwind_TI(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_upwind_result: Error allocating Dstread_upwind_resultData%upwind_TI.'
         RETURN
      END IF
   END IF
   Dstread_upwind_resultData%upwind_TI = Srcread_upwind_resultData%upwind_TI
ENDIF
IF (ALLOCATED(Srcread_upwind_resultData%upwind_small_TI)) THEN
   i1_l = LBOUND(Srcread_upwind_resultData%upwind_small_TI,1)
   i1_u = UBOUND(Srcread_upwind_resultData%upwind_small_TI,1)
   IF (.NOT. ALLOCATED(Dstread_upwind_resultData%upwind_small_TI)) THEN 
      ALLOCATE(Dstread_upwind_resultData%upwind_small_TI(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_upwind_result: Error allocating Dstread_upwind_resultData%upwind_small_TI.'
         RETURN
      END IF
   END IF
   Dstread_upwind_resultData%upwind_small_TI = Srcread_upwind_resultData%upwind_small_TI
ENDIF
IF (ALLOCATED(Srcread_upwind_resultData%upwind_smoothWake)) THEN
   i1_l = LBOUND(Srcread_upwind_resultData%upwind_smoothWake,1)
   i1_u = UBOUND(Srcread_upwind_resultData%upwind_smoothWake,1)
   i2_l = LBOUND(Srcread_upwind_resultData%upwind_smoothWake,2)
   i2_u = UBOUND(Srcread_upwind_resultData%upwind_smoothWake,2)
   IF (.NOT. ALLOCATED(Dstread_upwind_resultData%upwind_smoothWake)) THEN 
      ALLOCATE(Dstread_upwind_resultData%upwind_smoothWake(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_upwind_result: Error allocating Dstread_upwind_resultData%upwind_smoothWake.'
         RETURN
      END IF
   END IF
   Dstread_upwind_resultData%upwind_smoothWake = Srcread_upwind_resultData%upwind_smoothWake
ENDIF
IF (ALLOCATED(Srcread_upwind_resultData%velocity_aerodyn)) THEN
   i1_l = LBOUND(Srcread_upwind_resultData%velocity_aerodyn,1)
   i1_u = UBOUND(Srcread_upwind_resultData%velocity_aerodyn,1)
   IF (.NOT. ALLOCATED(Dstread_upwind_resultData%velocity_aerodyn)) THEN 
      ALLOCATE(Dstread_upwind_resultData%velocity_aerodyn(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_upwind_result: Error allocating Dstread_upwind_resultData%velocity_aerodyn.'
         RETURN
      END IF
   END IF
   Dstread_upwind_resultData%velocity_aerodyn = Srcread_upwind_resultData%velocity_aerodyn
ENDIF
IF (ALLOCATED(Srcread_upwind_resultData%TI_downstream)) THEN
   i1_l = LBOUND(Srcread_upwind_resultData%TI_downstream,1)
   i1_u = UBOUND(Srcread_upwind_resultData%TI_downstream,1)
   IF (.NOT. ALLOCATED(Dstread_upwind_resultData%TI_downstream)) THEN 
      ALLOCATE(Dstread_upwind_resultData%TI_downstream(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_upwind_result: Error allocating Dstread_upwind_resultData%TI_downstream.'
         RETURN
      END IF
   END IF
   Dstread_upwind_resultData%TI_downstream = Srcread_upwind_resultData%TI_downstream
ENDIF
IF (ALLOCATED(Srcread_upwind_resultData%small_scale_TI_downstream)) THEN
   i1_l = LBOUND(Srcread_upwind_resultData%small_scale_TI_downstream,1)
   i1_u = UBOUND(Srcread_upwind_resultData%small_scale_TI_downstream,1)
   IF (.NOT. ALLOCATED(Dstread_upwind_resultData%small_scale_TI_downstream)) THEN 
      ALLOCATE(Dstread_upwind_resultData%small_scale_TI_downstream(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_upwind_result: Error allocating Dstread_upwind_resultData%small_scale_TI_downstream.'
         RETURN
      END IF
   END IF
   Dstread_upwind_resultData%small_scale_TI_downstream = Srcread_upwind_resultData%small_scale_TI_downstream
ENDIF
IF (ALLOCATED(Srcread_upwind_resultData%smoothed_velocity_array)) THEN
   i1_l = LBOUND(Srcread_upwind_resultData%smoothed_velocity_array,1)
   i1_u = UBOUND(Srcread_upwind_resultData%smoothed_velocity_array,1)
   i2_l = LBOUND(Srcread_upwind_resultData%smoothed_velocity_array,2)
   i2_u = UBOUND(Srcread_upwind_resultData%smoothed_velocity_array,2)
   IF (.NOT. ALLOCATED(Dstread_upwind_resultData%smoothed_velocity_array)) THEN 
      ALLOCATE(Dstread_upwind_resultData%smoothed_velocity_array(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_upwind_result: Error allocating Dstread_upwind_resultData%smoothed_velocity_array.'
         RETURN
      END IF
   END IF
   Dstread_upwind_resultData%smoothed_velocity_array = Srcread_upwind_resultData%smoothed_velocity_array
ENDIF
IF (ALLOCATED(Srcread_upwind_resultData%vel_matrix)) THEN
   i1_l = LBOUND(Srcread_upwind_resultData%vel_matrix,1)
   i1_u = UBOUND(Srcread_upwind_resultData%vel_matrix,1)
   i2_l = LBOUND(Srcread_upwind_resultData%vel_matrix,2)
   i2_u = UBOUND(Srcread_upwind_resultData%vel_matrix,2)
   i3_l = LBOUND(Srcread_upwind_resultData%vel_matrix,3)
   i3_u = UBOUND(Srcread_upwind_resultData%vel_matrix,3)
   IF (.NOT. ALLOCATED(Dstread_upwind_resultData%vel_matrix)) THEN 
      ALLOCATE(Dstread_upwind_resultData%vel_matrix(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copyread_upwind_result: Error allocating Dstread_upwind_resultData%vel_matrix.'
         RETURN
      END IF
   END IF
   Dstread_upwind_resultData%vel_matrix = Srcread_upwind_resultData%vel_matrix
ENDIF
 END SUBROUTINE DWM_Copyread_upwind_result

 SUBROUTINE DWM_Destroyread_upwind_result( read_upwind_resultData, ErrStat, ErrMsg )
  TYPE(read_upwind_result), INTENT(INOUT) :: read_upwind_resultData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(read_upwind_resultData%upwind_U)) THEN
   DEALLOCATE(read_upwind_resultData%upwind_U)
ENDIF
IF (ALLOCATED(read_upwind_resultData%upwind_wakecenter)) THEN
   DEALLOCATE(read_upwind_resultData%upwind_wakecenter)
ENDIF
IF (ALLOCATED(read_upwind_resultData%upwind_meanU)) THEN
   DEALLOCATE(read_upwind_resultData%upwind_meanU)
ENDIF
IF (ALLOCATED(read_upwind_resultData%upwind_TI)) THEN
   DEALLOCATE(read_upwind_resultData%upwind_TI)
ENDIF
IF (ALLOCATED(read_upwind_resultData%upwind_small_TI)) THEN
   DEALLOCATE(read_upwind_resultData%upwind_small_TI)
ENDIF
IF (ALLOCATED(read_upwind_resultData%upwind_smoothWake)) THEN
   DEALLOCATE(read_upwind_resultData%upwind_smoothWake)
ENDIF
IF (ALLOCATED(read_upwind_resultData%velocity_aerodyn)) THEN
   DEALLOCATE(read_upwind_resultData%velocity_aerodyn)
ENDIF
IF (ALLOCATED(read_upwind_resultData%TI_downstream)) THEN
   DEALLOCATE(read_upwind_resultData%TI_downstream)
ENDIF
IF (ALLOCATED(read_upwind_resultData%small_scale_TI_downstream)) THEN
   DEALLOCATE(read_upwind_resultData%small_scale_TI_downstream)
ENDIF
IF (ALLOCATED(read_upwind_resultData%smoothed_velocity_array)) THEN
   DEALLOCATE(read_upwind_resultData%smoothed_velocity_array)
ENDIF
IF (ALLOCATED(read_upwind_resultData%vel_matrix)) THEN
   DEALLOCATE(read_upwind_resultData%vel_matrix)
ENDIF
 END SUBROUTINE DWM_Destroyread_upwind_result

 SUBROUTINE DWM_Packread_upwind_result( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(read_upwind_result),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%upwind_U )  ! upwind_U 
  Re_BufSz    = Re_BufSz    + SIZE( InData%upwind_wakecenter )  ! upwind_wakecenter 
  Re_BufSz    = Re_BufSz    + SIZE( InData%upwind_meanU )  ! upwind_meanU 
  Re_BufSz    = Re_BufSz    + SIZE( InData%upwind_TI )  ! upwind_TI 
  Re_BufSz    = Re_BufSz    + SIZE( InData%upwind_small_TI )  ! upwind_small_TI 
  Re_BufSz    = Re_BufSz    + SIZE( InData%upwind_smoothWake )  ! upwind_smoothWake 
  Re_BufSz    = Re_BufSz    + SIZE( InData%velocity_aerodyn )  ! velocity_aerodyn 
  Re_BufSz    = Re_BufSz    + SIZE( InData%TI_downstream )  ! TI_downstream 
  Re_BufSz    = Re_BufSz    + SIZE( InData%small_scale_TI_downstream )  ! small_scale_TI_downstream 
  Re_BufSz    = Re_BufSz    + SIZE( InData%smoothed_velocity_array )  ! smoothed_velocity_array 
  Re_BufSz    = Re_BufSz    + SIZE( InData%vel_matrix )  ! vel_matrix 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%upwind_U) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%upwind_U))-1 ) =  PACK(InData%upwind_U ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%upwind_U)
  ENDIF
  IF ( ALLOCATED(InData%upwind_wakecenter) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%upwind_wakecenter))-1 ) =  PACK(InData%upwind_wakecenter ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%upwind_wakecenter)
  ENDIF
  IF ( ALLOCATED(InData%upwind_meanU) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%upwind_meanU))-1 ) =  PACK(InData%upwind_meanU ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%upwind_meanU)
  ENDIF
  IF ( ALLOCATED(InData%upwind_TI) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%upwind_TI))-1 ) =  PACK(InData%upwind_TI ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%upwind_TI)
  ENDIF
  IF ( ALLOCATED(InData%upwind_small_TI) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%upwind_small_TI))-1 ) =  PACK(InData%upwind_small_TI ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%upwind_small_TI)
  ENDIF
  IF ( ALLOCATED(InData%upwind_smoothWake) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%upwind_smoothWake))-1 ) =  PACK(InData%upwind_smoothWake ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%upwind_smoothWake)
  ENDIF
  IF ( ALLOCATED(InData%velocity_aerodyn) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%velocity_aerodyn))-1 ) =  PACK(InData%velocity_aerodyn ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%velocity_aerodyn)
  ENDIF
  IF ( ALLOCATED(InData%TI_downstream) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TI_downstream))-1 ) =  PACK(InData%TI_downstream ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%TI_downstream)
  ENDIF
  IF ( ALLOCATED(InData%small_scale_TI_downstream) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%small_scale_TI_downstream))-1 ) =  PACK(InData%small_scale_TI_downstream ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%small_scale_TI_downstream)
  ENDIF
  IF ( ALLOCATED(InData%smoothed_velocity_array) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%smoothed_velocity_array))-1 ) =  PACK(InData%smoothed_velocity_array ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%smoothed_velocity_array)
  ENDIF
  IF ( ALLOCATED(InData%vel_matrix) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%vel_matrix))-1 ) =  PACK(InData%vel_matrix ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%vel_matrix)
  ENDIF
 END SUBROUTINE DWM_Packread_upwind_result

 SUBROUTINE DWM_UnPackread_upwind_result( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(read_upwind_result), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%upwind_U) ) THEN
  ALLOCATE(mask2(SIZE(OutData%upwind_U,1),SIZE(OutData%upwind_U,2))); mask2 = .TRUE.
    OutData%upwind_U = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%upwind_U))-1 ),mask2,OutData%upwind_U)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%upwind_U)
  ENDIF
  IF ( ALLOCATED(OutData%upwind_wakecenter) ) THEN
  ALLOCATE(mask4(SIZE(OutData%upwind_wakecenter,1),SIZE(OutData%upwind_wakecenter,2),SIZE(OutData%upwind_wakecenter,3),SIZE(OutData%upwind_wakecenter,4))); mask4 = .TRUE.
    OutData%upwind_wakecenter = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%upwind_wakecenter))-1 ),mask4,OutData%upwind_wakecenter)
  DEALLOCATE(mask4)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%upwind_wakecenter)
  ENDIF
  IF ( ALLOCATED(OutData%upwind_meanU) ) THEN
  ALLOCATE(mask1(SIZE(OutData%upwind_meanU,1))); mask1 = .TRUE.
    OutData%upwind_meanU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%upwind_meanU))-1 ),mask1,OutData%upwind_meanU)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%upwind_meanU)
  ENDIF
  IF ( ALLOCATED(OutData%upwind_TI) ) THEN
  ALLOCATE(mask1(SIZE(OutData%upwind_TI,1))); mask1 = .TRUE.
    OutData%upwind_TI = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%upwind_TI))-1 ),mask1,OutData%upwind_TI)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%upwind_TI)
  ENDIF
  IF ( ALLOCATED(OutData%upwind_small_TI) ) THEN
  ALLOCATE(mask1(SIZE(OutData%upwind_small_TI,1))); mask1 = .TRUE.
    OutData%upwind_small_TI = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%upwind_small_TI))-1 ),mask1,OutData%upwind_small_TI)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%upwind_small_TI)
  ENDIF
  IF ( ALLOCATED(OutData%upwind_smoothWake) ) THEN
  ALLOCATE(mask2(SIZE(OutData%upwind_smoothWake,1),SIZE(OutData%upwind_smoothWake,2))); mask2 = .TRUE.
    OutData%upwind_smoothWake = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%upwind_smoothWake))-1 ),mask2,OutData%upwind_smoothWake)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%upwind_smoothWake)
  ENDIF
  IF ( ALLOCATED(OutData%velocity_aerodyn) ) THEN
  ALLOCATE(mask1(SIZE(OutData%velocity_aerodyn,1))); mask1 = .TRUE.
    OutData%velocity_aerodyn = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%velocity_aerodyn))-1 ),mask1,OutData%velocity_aerodyn)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%velocity_aerodyn)
  ENDIF
  IF ( ALLOCATED(OutData%TI_downstream) ) THEN
  ALLOCATE(mask1(SIZE(OutData%TI_downstream,1))); mask1 = .TRUE.
    OutData%TI_downstream = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TI_downstream))-1 ),mask1,OutData%TI_downstream)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%TI_downstream)
  ENDIF
  IF ( ALLOCATED(OutData%small_scale_TI_downstream) ) THEN
  ALLOCATE(mask1(SIZE(OutData%small_scale_TI_downstream,1))); mask1 = .TRUE.
    OutData%small_scale_TI_downstream = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%small_scale_TI_downstream))-1 ),mask1,OutData%small_scale_TI_downstream)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%small_scale_TI_downstream)
  ENDIF
  IF ( ALLOCATED(OutData%smoothed_velocity_array) ) THEN
  ALLOCATE(mask2(SIZE(OutData%smoothed_velocity_array,1),SIZE(OutData%smoothed_velocity_array,2))); mask2 = .TRUE.
    OutData%smoothed_velocity_array = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%smoothed_velocity_array))-1 ),mask2,OutData%smoothed_velocity_array)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%smoothed_velocity_array)
  ENDIF
  IF ( ALLOCATED(OutData%vel_matrix) ) THEN
  ALLOCATE(mask3(SIZE(OutData%vel_matrix,1),SIZE(OutData%vel_matrix,2),SIZE(OutData%vel_matrix,3))); mask3 = .TRUE.
    OutData%vel_matrix = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%vel_matrix))-1 ),mask3,OutData%vel_matrix)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%vel_matrix)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE DWM_UnPackread_upwind_result

 SUBROUTINE DWM_Copywake_meandered_center( Srcwake_meandered_centerData, Dstwake_meandered_centerData, CtrlCode, ErrStat, ErrMsg )
   TYPE(wake_meandered_center), INTENT(INOUT) :: Srcwake_meandered_centerData
   TYPE(wake_meandered_center), INTENT(INOUT) :: Dstwake_meandered_centerData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(Srcwake_meandered_centerData%wake_width)) THEN
   i1_l = LBOUND(Srcwake_meandered_centerData%wake_width,1)
   i1_u = UBOUND(Srcwake_meandered_centerData%wake_width,1)
   IF (.NOT. ALLOCATED(Dstwake_meandered_centerData%wake_width)) THEN 
      ALLOCATE(Dstwake_meandered_centerData%wake_width(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_Copywake_meandered_center: Error allocating Dstwake_meandered_centerData%wake_width.'
         RETURN
      END IF
   END IF
   Dstwake_meandered_centerData%wake_width = Srcwake_meandered_centerData%wake_width
ENDIF
 END SUBROUTINE DWM_Copywake_meandered_center

 SUBROUTINE DWM_Destroywake_meandered_center( wake_meandered_centerData, ErrStat, ErrMsg )
  TYPE(wake_meandered_center), INTENT(INOUT) :: wake_meandered_centerData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(wake_meandered_centerData%wake_width)) THEN
   DEALLOCATE(wake_meandered_centerData%wake_width)
ENDIF
 END SUBROUTINE DWM_Destroywake_meandered_center

 SUBROUTINE DWM_Packwake_meandered_center( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(wake_meandered_center),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + SIZE( InData%wake_width )  ! wake_width 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%wake_width) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%wake_width))-1 ) = PACK(InData%wake_width ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%wake_width)
  ENDIF
 END SUBROUTINE DWM_Packwake_meandered_center

 SUBROUTINE DWM_UnPackwake_meandered_center( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(wake_meandered_center), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%wake_width) ) THEN
  ALLOCATE(mask1(SIZE(OutData%wake_width,1))); mask1 = .TRUE.
    OutData%wake_width = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%wake_width))-1 ),mask1,OutData%wake_width)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%wake_width)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE DWM_UnPackwake_meandered_center

 SUBROUTINE DWM_Copyturbine_blade( Srcturbine_bladeData, Dstturbine_bladeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(dwm_turbine_blade), INTENT(INOUT) :: Srcturbine_bladeData
   TYPE(dwm_turbine_blade), INTENT(INOUT) :: Dstturbine_bladeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   Dstturbine_bladeData%Aerodyn_turbine_num = Srcturbine_bladeData%Aerodyn_turbine_num
   Dstturbine_bladeData%Blade_index = Srcturbine_bladeData%Blade_index
   Dstturbine_bladeData%Element_index = Srcturbine_bladeData%Element_index
 END SUBROUTINE DWM_Copyturbine_blade

 SUBROUTINE DWM_Destroyturbine_blade( turbine_bladeData, ErrStat, ErrMsg )
  TYPE(dwm_turbine_blade), INTENT(INOUT) :: turbine_bladeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE DWM_Destroyturbine_blade

 SUBROUTINE DWM_Packturbine_blade( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(dwm_turbine_blade),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! Aerodyn_turbine_num
  Int_BufSz  = Int_BufSz  + 1  ! Blade_index
  Int_BufSz  = Int_BufSz  + 1  ! Element_index
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Aerodyn_turbine_num )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Blade_index )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Element_index )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE DWM_Packturbine_blade

 SUBROUTINE DWM_UnPackturbine_blade( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(dwm_turbine_blade), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%Aerodyn_turbine_num = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Blade_index = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Element_index = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE DWM_UnPackturbine_blade

 SUBROUTINE DWM_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(DWM_parametertype), INTENT(INOUT) :: SrcParamData
   TYPE(DWM_parametertype), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcParamData%velocityU)) THEN
   i1_l = LBOUND(SrcParamData%velocityU,1)
   i1_u = UBOUND(SrcParamData%velocityU,1)
   IF (.NOT. ALLOCATED(DstParamData%velocityU)) THEN 
      ALLOCATE(DstParamData%velocityU(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_CopyParam: Error allocating DstParamData%velocityU.'
         RETURN
      END IF
   END IF
   DstParamData%velocityU = SrcParamData%velocityU
ENDIF
IF (ALLOCATED(SrcParamData%smoothed_wake)) THEN
   i1_l = LBOUND(SrcParamData%smoothed_wake,1)
   i1_u = UBOUND(SrcParamData%smoothed_wake,1)
   IF (.NOT. ALLOCATED(DstParamData%smoothed_wake)) THEN 
      ALLOCATE(DstParamData%smoothed_wake(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_CopyParam: Error allocating DstParamData%smoothed_wake.'
         RETURN
      END IF
   END IF
   DstParamData%smoothed_wake = SrcParamData%smoothed_wake
ENDIF
IF (ALLOCATED(SrcParamData%WakePosition)) THEN
   i1_l = LBOUND(SrcParamData%WakePosition,1)
   i1_u = UBOUND(SrcParamData%WakePosition,1)
   i2_l = LBOUND(SrcParamData%WakePosition,2)
   i2_u = UBOUND(SrcParamData%WakePosition,2)
   i3_l = LBOUND(SrcParamData%WakePosition,3)
   i3_u = UBOUND(SrcParamData%WakePosition,3)
   IF (.NOT. ALLOCATED(DstParamData%WakePosition)) THEN 
      ALLOCATE(DstParamData%WakePosition(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_CopyParam: Error allocating DstParamData%WakePosition.'
         RETURN
      END IF
   END IF
   DstParamData%WakePosition = SrcParamData%WakePosition
ENDIF
   DstParamData%WakePosition_1 = SrcParamData%WakePosition_1
   DstParamData%WakePosition_2 = SrcParamData%WakePosition_2
   DstParamData%smooth_flag = SrcParamData%smooth_flag
   DstParamData%p_p_r = SrcParamData%p_p_r
   DstParamData%NumWT = SrcParamData%NumWT
   DstParamData%Tinfluencer = SrcParamData%Tinfluencer
   DstParamData%RotorR = SrcParamData%RotorR
   DstParamData%r_domain = SrcParamData%r_domain
   DstParamData%x_domain = SrcParamData%x_domain
   DstParamData%Uambient = SrcParamData%Uambient
   DstParamData%TI_amb = SrcParamData%TI_amb
   DstParamData%TI_wake = SrcParamData%TI_wake
   DstParamData%hub_height = SrcParamData%hub_height
   DstParamData%length_velocityU = SrcParamData%length_velocityU
   DstParamData%TurbRefHt = SrcParamData%TurbRefHt
   DstParamData%Wind_file_Mean_u = SrcParamData%Wind_file_Mean_u
   DstParamData%Winddir = SrcParamData%Winddir
   DstParamData%air_density = SrcParamData%air_density
   DstParamData%RR = SrcParamData%RR
IF (ALLOCATED(SrcParamData%ElementRad)) THEN
   i1_l = LBOUND(SrcParamData%ElementRad,1)
   i1_u = UBOUND(SrcParamData%ElementRad,1)
   IF (.NOT. ALLOCATED(DstParamData%ElementRad)) THEN 
      ALLOCATE(DstParamData%ElementRad(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_CopyParam: Error allocating DstParamData%ElementRad.'
         RETURN
      END IF
   END IF
   DstParamData%ElementRad = SrcParamData%ElementRad
ENDIF
   DstParamData%Bnum = SrcParamData%Bnum
   DstParamData%ElementNum = SrcParamData%ElementNum
      CALL DWM_Copyread_turbine_position_data( SrcParamData%RTPD, DstParamData%RTPD, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE DWM_CopyParam

 SUBROUTINE DWM_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(DWM_parametertype), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%velocityU)) THEN
   DEALLOCATE(ParamData%velocityU)
ENDIF
IF (ALLOCATED(ParamData%smoothed_wake)) THEN
   DEALLOCATE(ParamData%smoothed_wake)
ENDIF
IF (ALLOCATED(ParamData%WakePosition)) THEN
   DEALLOCATE(ParamData%WakePosition)
ENDIF
IF (ALLOCATED(ParamData%ElementRad)) THEN
   DEALLOCATE(ParamData%ElementRad)
ENDIF
  CALL DWM_Destroyread_turbine_position_data( ParamData%RTPD, ErrStat, ErrMsg )
 END SUBROUTINE DWM_DestroyParam

 SUBROUTINE DWM_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(DWM_parametertype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_RTPD_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_RTPD_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_RTPD_Buf(:)
 SUBROUTINE DWM_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(DWM_parametertype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_RTPD_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_RTPD_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_RTPD_Buf(:)
 SUBROUTINE DWM_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(DWM_otherstatetype), INTENT(INOUT) :: SrcOtherStateData
   TYPE(DWM_otherstatetype), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstOtherStateData%position_y = SrcOtherStateData%position_y
   DstOtherStateData%position_z = SrcOtherStateData%position_z
   DstOtherStateData%velocity_wake_mean = SrcOtherStateData%velocity_wake_mean
   DstOtherStateData%shifted_velocity_Aerodyn = SrcOtherStateData%shifted_velocity_Aerodyn
   DstOtherStateData%U_velocity = SrcOtherStateData%U_velocity
   DstOtherStateData%V_velocity = SrcOtherStateData%V_velocity
IF (ALLOCATED(SrcOtherStateData%Nforce)) THEN
   i1_l = LBOUND(SrcOtherStateData%Nforce,1)
   i1_u = UBOUND(SrcOtherStateData%Nforce,1)
   i2_l = LBOUND(SrcOtherStateData%Nforce,2)
   i2_u = UBOUND(SrcOtherStateData%Nforce,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%Nforce)) THEN 
      ALLOCATE(DstOtherStateData%Nforce(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_CopyOtherState: Error allocating DstOtherStateData%Nforce.'
         RETURN
      END IF
   END IF
   DstOtherStateData%Nforce = SrcOtherStateData%Nforce
ENDIF
IF (ALLOCATED(SrcOtherStateData%blade_dr)) THEN
   i1_l = LBOUND(SrcOtherStateData%blade_dr,1)
   i1_u = UBOUND(SrcOtherStateData%blade_dr,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%blade_dr)) THEN 
      ALLOCATE(DstOtherStateData%blade_dr(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_CopyOtherState: Error allocating DstOtherStateData%blade_dr.'
         RETURN
      END IF
   END IF
   DstOtherStateData%blade_dr = SrcOtherStateData%blade_dr
ENDIF
   DstOtherStateData%NacYaw = SrcOtherStateData%NacYaw
   DstOtherStateData%TI_original = SrcOtherStateData%TI_original
      CALL DWM_Copyturbine_average_velocity_data( SrcOtherStateData%TAVD, DstOtherStateData%TAVD, CtrlCode, ErrStat, ErrMsg )
      CALL DWM_Copycvsd( SrcOtherStateData%CalVelScale_data, DstOtherStateData%CalVelScale_data, CtrlCode, ErrStat, ErrMsg )
      CALL DWM_Copymeanderdata( SrcOtherStateData%meandering_data, DstOtherStateData%meandering_data, CtrlCode, ErrStat, ErrMsg )
      CALL DWM_Copyweimethod( SrcOtherStateData%weighting_method, DstOtherStateData%weighting_method, CtrlCode, ErrStat, ErrMsg )
      CALL DWM_Copytidownstream( SrcOtherStateData%TI_downstream_data, DstOtherStateData%TI_downstream_data, CtrlCode, ErrStat, ErrMsg )
      CALL DWM_Copyturbkaimal( SrcOtherStateData%Turbulence_KS, DstOtherStateData%Turbulence_KS, CtrlCode, ErrStat, ErrMsg )
      CALL DWM_Copyshinozuka( SrcOtherStateData%shinozuka_data, DstOtherStateData%shinozuka_data, CtrlCode, ErrStat, ErrMsg )
      CALL DWM_Copysmooth_out_wake_data( SrcOtherStateData%SmoothOut, DstOtherStateData%SmoothOut, CtrlCode, ErrStat, ErrMsg )
      CALL DWM_Copyswsv( SrcOtherStateData%smooth_wake_shifted_velocity_data, DstOtherStateData%smooth_wake_shifted_velocity_data, CtrlCode, ErrStat, ErrMsg )
      CALL DWM_Copywake_deficit_data( SrcOtherStateData%DWDD, DstOtherStateData%DWDD, CtrlCode, ErrStat, ErrMsg )
   DstOtherStateData%ct_tilde = SrcOtherStateData%ct_tilde
   DstOtherStateData%FAST_Time = SrcOtherStateData%FAST_Time
   DstOtherStateData%SDtimestep = SrcOtherStateData%SDtimestep
      CALL DWM_Copyturbine_blade( SrcOtherStateData%DWM_tb, DstOtherStateData%DWM_tb, CtrlCode, ErrStat, ErrMsg )
      CALL DWM_Copywake_meandered_center( SrcOtherStateData%WMC, DstOtherStateData%WMC, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE DWM_CopyOtherState

 SUBROUTINE DWM_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(DWM_otherstatetype), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OtherStateData%Nforce)) THEN
   DEALLOCATE(OtherStateData%Nforce)
ENDIF
IF (ALLOCATED(OtherStateData%blade_dr)) THEN
   DEALLOCATE(OtherStateData%blade_dr)
ENDIF
  CALL DWM_Destroyturbine_average_velocity_data( OtherStateData%TAVD, ErrStat, ErrMsg )
  CALL DWM_Destroycvsd( OtherStateData%CalVelScale_data, ErrStat, ErrMsg )
  CALL DWM_Destroymeanderdata( OtherStateData%meandering_data, ErrStat, ErrMsg )
  CALL DWM_Destroyweimethod( OtherStateData%weighting_method, ErrStat, ErrMsg )
  CALL DWM_Destroytidownstream( OtherStateData%TI_downstream_data, ErrStat, ErrMsg )
  CALL DWM_Destroyturbkaimal( OtherStateData%Turbulence_KS, ErrStat, ErrMsg )
  CALL DWM_Destroyshinozuka( OtherStateData%shinozuka_data, ErrStat, ErrMsg )
  CALL DWM_Destroysmooth_out_wake_data( OtherStateData%SmoothOut, ErrStat, ErrMsg )
  CALL DWM_Destroyswsv( OtherStateData%smooth_wake_shifted_velocity_data, ErrStat, ErrMsg )
  CALL DWM_Destroywake_deficit_data( OtherStateData%DWDD, ErrStat, ErrMsg )
  CALL DWM_Destroyturbine_blade( OtherStateData%DWM_tb, ErrStat, ErrMsg )
  CALL DWM_Destroywake_meandered_center( OtherStateData%WMC, ErrStat, ErrMsg )
 END SUBROUTINE DWM_DestroyOtherState

 SUBROUTINE DWM_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(DWM_otherstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_TAVD_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_TAVD_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_TAVD_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_CalVelScale_data_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_CalVelScale_data_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_CalVelScale_data_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_meandering_data_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_meandering_data_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_meandering_data_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_weighting_method_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_weighting_method_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_weighting_method_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_TI_downstream_data_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_TI_downstream_data_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_TI_downstream_data_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_Turbulence_KS_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Turbulence_KS_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Turbulence_KS_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_shinozuka_data_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_shinozuka_data_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_shinozuka_data_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_SmoothOut_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_SmoothOut_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_SmoothOut_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_smooth_wake_shifted_velocity_data_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_smooth_wake_shifted_velocity_data_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_smooth_wake_shifted_velocity_data_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_DWDD_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DWDD_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DWDD_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_DWM_tb_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DWM_tb_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DWM_tb_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_WMC_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_WMC_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_WMC_Buf(:)
 SUBROUTINE DWM_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(DWM_otherstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_TAVD_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_TAVD_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_TAVD_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_CalVelScale_data_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_CalVelScale_data_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_CalVelScale_data_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_meandering_data_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_meandering_data_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_meandering_data_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_weighting_method_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_weighting_method_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_weighting_method_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_TI_downstream_data_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_TI_downstream_data_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_TI_downstream_data_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_Turbulence_KS_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Turbulence_KS_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Turbulence_KS_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_shinozuka_data_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_shinozuka_data_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_shinozuka_data_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_SmoothOut_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_SmoothOut_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_SmoothOut_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_smooth_wake_shifted_velocity_data_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_smooth_wake_shifted_velocity_data_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_smooth_wake_shifted_velocity_data_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_DWDD_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DWDD_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DWDD_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_DWM_tb_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DWM_tb_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DWM_tb_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_WMC_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_WMC_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_WMC_Buf(:)
 SUBROUTINE DWM_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(DWM_inputtype), INTENT(INOUT) :: SrcInputData
   TYPE(DWM_inputtype), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL DWM_Copyread_upwind_result( SrcInputData%Upwind_result, DstInputData%Upwind_result, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE DWM_CopyInput

 SUBROUTINE DWM_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(DWM_inputtype), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL DWM_Destroyread_upwind_result( InputData%Upwind_result, ErrStat, ErrMsg )
 END SUBROUTINE DWM_DestroyInput

 SUBROUTINE DWM_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(DWM_inputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Upwind_result_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Upwind_result_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Upwind_result_Buf(:)
 SUBROUTINE DWM_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(DWM_inputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Upwind_result_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Upwind_result_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Upwind_result_Buf(:)
 SUBROUTINE DWM_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(DWM_outputtype), INTENT(INOUT) :: SrcOutputData
   TYPE(DWM_outputtype), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%turbine_thrust_force)) THEN
   i1_l = LBOUND(SrcOutputData%turbine_thrust_force,1)
   i1_u = UBOUND(SrcOutputData%turbine_thrust_force,1)
   IF (.NOT. ALLOCATED(DstOutputData%turbine_thrust_force)) THEN 
      ALLOCATE(DstOutputData%turbine_thrust_force(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_CopyOutput: Error allocating DstOutputData%turbine_thrust_force.'
         RETURN
      END IF
   END IF
   DstOutputData%turbine_thrust_force = SrcOutputData%turbine_thrust_force
ENDIF
IF (ALLOCATED(SrcOutputData%induction_factor)) THEN
   i1_l = LBOUND(SrcOutputData%induction_factor,1)
   i1_u = UBOUND(SrcOutputData%induction_factor,1)
   IF (.NOT. ALLOCATED(DstOutputData%induction_factor)) THEN 
      ALLOCATE(DstOutputData%induction_factor(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_CopyOutput: Error allocating DstOutputData%induction_factor.'
         RETURN
      END IF
   END IF
   DstOutputData%induction_factor = SrcOutputData%induction_factor
ENDIF
IF (ALLOCATED(SrcOutputData%r_initial)) THEN
   i1_l = LBOUND(SrcOutputData%r_initial,1)
   i1_u = UBOUND(SrcOutputData%r_initial,1)
   IF (.NOT. ALLOCATED(DstOutputData%r_initial)) THEN 
      ALLOCATE(DstOutputData%r_initial(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_CopyOutput: Error allocating DstOutputData%r_initial.'
         RETURN
      END IF
   END IF
   DstOutputData%r_initial = SrcOutputData%r_initial
ENDIF
IF (ALLOCATED(SrcOutputData%U_initial)) THEN
   i1_l = LBOUND(SrcOutputData%U_initial,1)
   i1_u = UBOUND(SrcOutputData%U_initial,1)
   IF (.NOT. ALLOCATED(DstOutputData%U_initial)) THEN 
      ALLOCATE(DstOutputData%U_initial(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_CopyOutput: Error allocating DstOutputData%U_initial.'
         RETURN
      END IF
   END IF
   DstOutputData%U_initial = SrcOutputData%U_initial
ENDIF
IF (ALLOCATED(SrcOutputData%Mean_FFWS_array)) THEN
   i1_l = LBOUND(SrcOutputData%Mean_FFWS_array,1)
   i1_u = UBOUND(SrcOutputData%Mean_FFWS_array,1)
   IF (.NOT. ALLOCATED(DstOutputData%Mean_FFWS_array)) THEN 
      ALLOCATE(DstOutputData%Mean_FFWS_array(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_CopyOutput: Error allocating DstOutputData%Mean_FFWS_array.'
         RETURN
      END IF
   END IF
   DstOutputData%Mean_FFWS_array = SrcOutputData%Mean_FFWS_array
ENDIF
   DstOutputData%Mean_FFWS = SrcOutputData%Mean_FFWS
   DstOutputData%TI = SrcOutputData%TI
   DstOutputData%TI_downstream = SrcOutputData%TI_downstream
IF (ALLOCATED(SrcOutputData%wake_u)) THEN
   i1_l = LBOUND(SrcOutputData%wake_u,1)
   i1_u = UBOUND(SrcOutputData%wake_u,1)
   i2_l = LBOUND(SrcOutputData%wake_u,2)
   i2_u = UBOUND(SrcOutputData%wake_u,2)
   IF (.NOT. ALLOCATED(DstOutputData%wake_u)) THEN 
      ALLOCATE(DstOutputData%wake_u(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_CopyOutput: Error allocating DstOutputData%wake_u.'
         RETURN
      END IF
   END IF
   DstOutputData%wake_u = SrcOutputData%wake_u
ENDIF
IF (ALLOCATED(SrcOutputData%wake_position)) THEN
   i1_l = LBOUND(SrcOutputData%wake_position,1)
   i1_u = UBOUND(SrcOutputData%wake_position,1)
   i2_l = LBOUND(SrcOutputData%wake_position,2)
   i2_u = UBOUND(SrcOutputData%wake_position,2)
   i3_l = LBOUND(SrcOutputData%wake_position,3)
   i3_u = UBOUND(SrcOutputData%wake_position,3)
   IF (.NOT. ALLOCATED(DstOutputData%wake_position)) THEN 
      ALLOCATE(DstOutputData%wake_position(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_CopyOutput: Error allocating DstOutputData%wake_position.'
         RETURN
      END IF
   END IF
   DstOutputData%wake_position = SrcOutputData%wake_position
ENDIF
IF (ALLOCATED(SrcOutputData%smoothed_velocity_array)) THEN
   i1_l = LBOUND(SrcOutputData%smoothed_velocity_array,1)
   i1_u = UBOUND(SrcOutputData%smoothed_velocity_array,1)
   i2_l = LBOUND(SrcOutputData%smoothed_velocity_array,2)
   i2_u = UBOUND(SrcOutputData%smoothed_velocity_array,2)
   IF (.NOT. ALLOCATED(DstOutputData%smoothed_velocity_array)) THEN 
      ALLOCATE(DstOutputData%smoothed_velocity_array(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'DWM_CopyOutput: Error allocating DstOutputData%smoothed_velocity_array.'
         RETURN
      END IF
   END IF
   DstOutputData%smoothed_velocity_array = SrcOutputData%smoothed_velocity_array
ENDIF
   DstOutputData%AtmUscale = SrcOutputData%AtmUscale
   DstOutputData%du_dz_ABL = SrcOutputData%du_dz_ABL
   DstOutputData%total_SDgenpwr = SrcOutputData%total_SDgenpwr
   DstOutputData%mean_SDgenpwr = SrcOutputData%mean_SDgenpwr
   DstOutputData%avg_ct = SrcOutputData%avg_ct
 END SUBROUTINE DWM_CopyOutput

 SUBROUTINE DWM_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(DWM_outputtype), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OutputData%turbine_thrust_force)) THEN
   DEALLOCATE(OutputData%turbine_thrust_force)
ENDIF
IF (ALLOCATED(OutputData%induction_factor)) THEN
   DEALLOCATE(OutputData%induction_factor)
ENDIF
IF (ALLOCATED(OutputData%r_initial)) THEN
   DEALLOCATE(OutputData%r_initial)
ENDIF
IF (ALLOCATED(OutputData%U_initial)) THEN
   DEALLOCATE(OutputData%U_initial)
ENDIF
IF (ALLOCATED(OutputData%Mean_FFWS_array)) THEN
   DEALLOCATE(OutputData%Mean_FFWS_array)
ENDIF
IF (ALLOCATED(OutputData%wake_u)) THEN
   DEALLOCATE(OutputData%wake_u)
ENDIF
IF (ALLOCATED(OutputData%wake_position)) THEN
   DEALLOCATE(OutputData%wake_position)
ENDIF
IF (ALLOCATED(OutputData%smoothed_velocity_array)) THEN
   DEALLOCATE(OutputData%smoothed_velocity_array)
ENDIF
 END SUBROUTINE DWM_DestroyOutput

 SUBROUTINE DWM_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(DWM_outputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
 SUBROUTINE DWM_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(DWM_outputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
 SUBROUTINE DWM_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(DWM_continuousstatetype), INTENT(INOUT) :: SrcContStateData
   TYPE(DWM_continuousstatetype), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstContStateData%dummy = SrcContStateData%dummy
 END SUBROUTINE DWM_CopyContState

 SUBROUTINE DWM_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(DWM_continuousstatetype), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE DWM_DestroyContState

 SUBROUTINE DWM_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(DWM_continuousstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
 SUBROUTINE DWM_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(DWM_continuousstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
 SUBROUTINE DWM_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(DWM_discretestatetype), INTENT(INOUT) :: SrcDiscStateData
   TYPE(DWM_discretestatetype), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%dummy = SrcDiscStateData%dummy
 END SUBROUTINE DWM_CopyDiscState

 SUBROUTINE DWM_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(DWM_discretestatetype), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE DWM_DestroyDiscState

 SUBROUTINE DWM_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(DWM_discretestatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
 SUBROUTINE DWM_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(DWM_discretestatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
 SUBROUTINE DWM_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(DWM_constraintstatetype), INTENT(INOUT) :: SrcConstrStateData
   TYPE(DWM_constraintstatetype), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%dummy = SrcConstrStateData%dummy
 END SUBROUTINE DWM_CopyConstrState

 SUBROUTINE DWM_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(DWM_constraintstatetype), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE DWM_DestroyConstrState

 SUBROUTINE DWM_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(DWM_constraintstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
 SUBROUTINE DWM_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(DWM_constraintstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
 SUBROUTINE DWM_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(DWM_initinputtype), INTENT(INOUT) :: SrcInitInputData
   TYPE(DWM_initinputtype), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%dummy = SrcInitInputData%dummy
   DstInitInputData%WindFileName = SrcInitInputData%WindFileName
   DstInitInputData%ReferenceHeight = SrcInitInputData%ReferenceHeight
   DstInitInputData%Width = SrcInitInputData%Width
   DstInitInputData%WindFileType = SrcInitInputData%WindFileType
 END SUBROUTINE DWM_CopyInitInput

 SUBROUTINE DWM_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(DWM_initinputtype), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE DWM_DestroyInitInput

 SUBROUTINE DWM_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(DWM_initinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
 SUBROUTINE DWM_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(DWM_initinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
 SUBROUTINE DWM_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(DWM_initoutputtype), INTENT(INOUT) :: SrcInitOutputData
   TYPE(DWM_initoutputtype), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitOutputData%dummy = SrcInitOutputData%dummy
 END SUBROUTINE DWM_CopyInitOutput

 SUBROUTINE DWM_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(DWM_initoutputtype), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE DWM_DestroyInitOutput

 SUBROUTINE DWM_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(DWM_initoutputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
 SUBROUTINE DWM_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(DWM_initoutputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any

 SUBROUTINE DWM_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(DWM_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(DWM_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in DWM_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in DWM_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%Upwind_result%upwind_U) .AND. ALLOCATED(u(1)%Upwind_result%upwind_U)) THEN
  u_out%Upwind_result%upwind_U = u(1)%Upwind_result%upwind_U
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_wakecenter) .AND. ALLOCATED(u(1)%Upwind_result%upwind_wakecenter)) THEN
  u_out%Upwind_result%upwind_wakecenter = u(1)%Upwind_result%upwind_wakecenter
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_meanU) .AND. ALLOCATED(u(1)%Upwind_result%upwind_meanU)) THEN
  u_out%Upwind_result%upwind_meanU = u(1)%Upwind_result%upwind_meanU
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_TI) .AND. ALLOCATED(u(1)%Upwind_result%upwind_TI)) THEN
  u_out%Upwind_result%upwind_TI = u(1)%Upwind_result%upwind_TI
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_small_TI) .AND. ALLOCATED(u(1)%Upwind_result%upwind_small_TI)) THEN
  u_out%Upwind_result%upwind_small_TI = u(1)%Upwind_result%upwind_small_TI
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_smoothWake) .AND. ALLOCATED(u(1)%Upwind_result%upwind_smoothWake)) THEN
  u_out%Upwind_result%upwind_smoothWake = u(1)%Upwind_result%upwind_smoothWake
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%velocity_aerodyn) .AND. ALLOCATED(u(1)%Upwind_result%velocity_aerodyn)) THEN
  u_out%Upwind_result%velocity_aerodyn = u(1)%Upwind_result%velocity_aerodyn
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%TI_downstream) .AND. ALLOCATED(u(1)%Upwind_result%TI_downstream)) THEN
  u_out%Upwind_result%TI_downstream = u(1)%Upwind_result%TI_downstream
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%small_scale_TI_downstream) .AND. ALLOCATED(u(1)%Upwind_result%small_scale_TI_downstream)) THEN
  u_out%Upwind_result%small_scale_TI_downstream = u(1)%Upwind_result%small_scale_TI_downstream
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%smoothed_velocity_array) .AND. ALLOCATED(u(1)%Upwind_result%smoothed_velocity_array)) THEN
  u_out%Upwind_result%smoothed_velocity_array = u(1)%Upwind_result%smoothed_velocity_array
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%vel_matrix) .AND. ALLOCATED(u(1)%Upwind_result%vel_matrix)) THEN
  u_out%Upwind_result%vel_matrix = u(1)%Upwind_result%vel_matrix
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in DWM_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%Upwind_result%upwind_U) .AND. ALLOCATED(u(1)%Upwind_result%upwind_U)) THEN
  ALLOCATE(b2(SIZE(u_out%Upwind_result%upwind_U,1),SIZE(u_out%Upwind_result%upwind_U,2) ))
  ALLOCATE(c2(SIZE(u_out%Upwind_result%upwind_U,1),SIZE(u_out%Upwind_result%upwind_U,2) ))
  b2 = -(u(1)%Upwind_result%upwind_U - u(2)%Upwind_result%upwind_U)/t(2)
  u_out%Upwind_result%upwind_U = u(1)%Upwind_result%upwind_U + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_wakecenter) .AND. ALLOCATED(u(1)%Upwind_result%upwind_wakecenter)) THEN
  ALLOCATE(b4(SIZE(u_out%Upwind_result%upwind_wakecenter,1),SIZE(u_out%Upwind_result%upwind_wakecenter,2), &
              SIZE(u_out%Upwind_result%upwind_wakecenter,3),SIZE(u_out%Upwind_result%upwind_wakecenter,4) ))
  ALLOCATE(c4(SIZE(u_out%Upwind_result%upwind_wakecenter,1),SIZE(u_out%Upwind_result%upwind_wakecenter,2), &
              SIZE(u_out%Upwind_result%upwind_wakecenter,3),SIZE(u_out%Upwind_result%upwind_wakecenter,4) ))
  b4 = -(u(1)%Upwind_result%upwind_wakecenter - u(2)%Upwind_result%upwind_wakecenter)/t(2)
  u_out%Upwind_result%upwind_wakecenter = u(1)%Upwind_result%upwind_wakecenter + b4 * t_out
  DEALLOCATE(b4)
  DEALLOCATE(c4)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_meanU) .AND. ALLOCATED(u(1)%Upwind_result%upwind_meanU)) THEN
  ALLOCATE(b1(SIZE(u_out%Upwind_result%upwind_meanU,1)))
  ALLOCATE(c1(SIZE(u_out%Upwind_result%upwind_meanU,1)))
  b1 = -(u(1)%Upwind_result%upwind_meanU - u(2)%Upwind_result%upwind_meanU)/t(2)
  u_out%Upwind_result%upwind_meanU = u(1)%Upwind_result%upwind_meanU + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_TI) .AND. ALLOCATED(u(1)%Upwind_result%upwind_TI)) THEN
  ALLOCATE(b1(SIZE(u_out%Upwind_result%upwind_TI,1)))
  ALLOCATE(c1(SIZE(u_out%Upwind_result%upwind_TI,1)))
  b1 = -(u(1)%Upwind_result%upwind_TI - u(2)%Upwind_result%upwind_TI)/t(2)
  u_out%Upwind_result%upwind_TI = u(1)%Upwind_result%upwind_TI + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_small_TI) .AND. ALLOCATED(u(1)%Upwind_result%upwind_small_TI)) THEN
  ALLOCATE(b1(SIZE(u_out%Upwind_result%upwind_small_TI,1)))
  ALLOCATE(c1(SIZE(u_out%Upwind_result%upwind_small_TI,1)))
  b1 = -(u(1)%Upwind_result%upwind_small_TI - u(2)%Upwind_result%upwind_small_TI)/t(2)
  u_out%Upwind_result%upwind_small_TI = u(1)%Upwind_result%upwind_small_TI + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_smoothWake) .AND. ALLOCATED(u(1)%Upwind_result%upwind_smoothWake)) THEN
  ALLOCATE(b2(SIZE(u_out%Upwind_result%upwind_smoothWake,1),SIZE(u_out%Upwind_result%upwind_smoothWake,2) ))
  ALLOCATE(c2(SIZE(u_out%Upwind_result%upwind_smoothWake,1),SIZE(u_out%Upwind_result%upwind_smoothWake,2) ))
  b2 = -(u(1)%Upwind_result%upwind_smoothWake - u(2)%Upwind_result%upwind_smoothWake)/t(2)
  u_out%Upwind_result%upwind_smoothWake = u(1)%Upwind_result%upwind_smoothWake + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%velocity_aerodyn) .AND. ALLOCATED(u(1)%Upwind_result%velocity_aerodyn)) THEN
  ALLOCATE(b1(SIZE(u_out%Upwind_result%velocity_aerodyn,1)))
  ALLOCATE(c1(SIZE(u_out%Upwind_result%velocity_aerodyn,1)))
  b1 = -(u(1)%Upwind_result%velocity_aerodyn - u(2)%Upwind_result%velocity_aerodyn)/t(2)
  u_out%Upwind_result%velocity_aerodyn = u(1)%Upwind_result%velocity_aerodyn + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%TI_downstream) .AND. ALLOCATED(u(1)%Upwind_result%TI_downstream)) THEN
  ALLOCATE(b1(SIZE(u_out%Upwind_result%TI_downstream,1)))
  ALLOCATE(c1(SIZE(u_out%Upwind_result%TI_downstream,1)))
  b1 = -(u(1)%Upwind_result%TI_downstream - u(2)%Upwind_result%TI_downstream)/t(2)
  u_out%Upwind_result%TI_downstream = u(1)%Upwind_result%TI_downstream + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%small_scale_TI_downstream) .AND. ALLOCATED(u(1)%Upwind_result%small_scale_TI_downstream)) THEN
  ALLOCATE(b1(SIZE(u_out%Upwind_result%small_scale_TI_downstream,1)))
  ALLOCATE(c1(SIZE(u_out%Upwind_result%small_scale_TI_downstream,1)))
  b1 = -(u(1)%Upwind_result%small_scale_TI_downstream - u(2)%Upwind_result%small_scale_TI_downstream)/t(2)
  u_out%Upwind_result%small_scale_TI_downstream = u(1)%Upwind_result%small_scale_TI_downstream + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%smoothed_velocity_array) .AND. ALLOCATED(u(1)%Upwind_result%smoothed_velocity_array)) THEN
  ALLOCATE(b2(SIZE(u_out%Upwind_result%smoothed_velocity_array,1),SIZE(u_out%Upwind_result%smoothed_velocity_array,2) ))
  ALLOCATE(c2(SIZE(u_out%Upwind_result%smoothed_velocity_array,1),SIZE(u_out%Upwind_result%smoothed_velocity_array,2) ))
  b2 = -(u(1)%Upwind_result%smoothed_velocity_array - u(2)%Upwind_result%smoothed_velocity_array)/t(2)
  u_out%Upwind_result%smoothed_velocity_array = u(1)%Upwind_result%smoothed_velocity_array + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%vel_matrix) .AND. ALLOCATED(u(1)%Upwind_result%vel_matrix)) THEN
  ALLOCATE(b3(SIZE(u_out%Upwind_result%vel_matrix,1),SIZE(u_out%Upwind_result%vel_matrix,2), &
              SIZE(u_out%Upwind_result%vel_matrix,3)                     ))
  ALLOCATE(c3(SIZE(u_out%Upwind_result%vel_matrix,1),SIZE(u_out%Upwind_result%vel_matrix,2), &
              SIZE(u_out%Upwind_result%vel_matrix,3)                     ))
  b3 = -(u(1)%Upwind_result%vel_matrix - u(2)%Upwind_result%vel_matrix)/t(2)
  u_out%Upwind_result%vel_matrix = u(1)%Upwind_result%vel_matrix + b3 * t_out
  DEALLOCATE(b3)
  DEALLOCATE(c3)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in DWM_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in DWM_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in DWM_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%Upwind_result%upwind_U) .AND. ALLOCATED(u(1)%Upwind_result%upwind_U)) THEN
  ALLOCATE(b2(SIZE(u_out%Upwind_result%upwind_U,1),SIZE(u_out%Upwind_result%upwind_U,2) ))
  ALLOCATE(c2(SIZE(u_out%Upwind_result%upwind_U,1),SIZE(u_out%Upwind_result%upwind_U,2) ))
  b2 = (t(3)**2*(u(1)%Upwind_result%upwind_U - u(2)%Upwind_result%upwind_U) + t(2)**2*(-u(1)%Upwind_result%upwind_U + u(3)%Upwind_result%upwind_U))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Upwind_result%upwind_U + t(3)*u(2)%Upwind_result%upwind_U - t(2)*u(3)%Upwind_result%upwind_U ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Upwind_result%upwind_U = u(1)%Upwind_result%upwind_U + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_wakecenter) .AND. ALLOCATED(u(1)%Upwind_result%upwind_wakecenter)) THEN
  ALLOCATE(b4(SIZE(u_out%Upwind_result%upwind_wakecenter,1),SIZE(u_out%Upwind_result%upwind_wakecenter,2), &
              SIZE(u_out%Upwind_result%upwind_wakecenter,3),SIZE(u_out%Upwind_result%upwind_wakecenter,4) ))
  ALLOCATE(c4(SIZE(u_out%Upwind_result%upwind_wakecenter,1),SIZE(u_out%Upwind_result%upwind_wakecenter,2), &
              SIZE(u_out%Upwind_result%upwind_wakecenter,3),SIZE(u_out%Upwind_result%upwind_wakecenter,4) ))
  b4 = (t(3)**2*(u(1)%Upwind_result%upwind_wakecenter - u(2)%Upwind_result%upwind_wakecenter) + t(2)**2*(-u(1)%Upwind_result%upwind_wakecenter + u(3)%Upwind_result%upwind_wakecenter))/(t(2)*t(3)*(t(2) - t(3)))
  c4 = ( (t(2)-t(3))*u(1)%Upwind_result%upwind_wakecenter + t(3)*u(2)%Upwind_result%upwind_wakecenter - t(2)*u(3)%Upwind_result%upwind_wakecenter ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Upwind_result%upwind_wakecenter = u(1)%Upwind_result%upwind_wakecenter + b4 * t_out + c4 * t_out**2
  DEALLOCATE(b4)
  DEALLOCATE(c4)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_meanU) .AND. ALLOCATED(u(1)%Upwind_result%upwind_meanU)) THEN
  ALLOCATE(b1(SIZE(u_out%Upwind_result%upwind_meanU,1)))
  ALLOCATE(c1(SIZE(u_out%Upwind_result%upwind_meanU,1)))
  b1 = (t(3)**2*(u(1)%Upwind_result%upwind_meanU - u(2)%Upwind_result%upwind_meanU) + t(2)**2*(-u(1)%Upwind_result%upwind_meanU + u(3)%Upwind_result%upwind_meanU))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Upwind_result%upwind_meanU + t(3)*u(2)%Upwind_result%upwind_meanU - t(2)*u(3)%Upwind_result%upwind_meanU ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Upwind_result%upwind_meanU = u(1)%Upwind_result%upwind_meanU + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_TI) .AND. ALLOCATED(u(1)%Upwind_result%upwind_TI)) THEN
  ALLOCATE(b1(SIZE(u_out%Upwind_result%upwind_TI,1)))
  ALLOCATE(c1(SIZE(u_out%Upwind_result%upwind_TI,1)))
  b1 = (t(3)**2*(u(1)%Upwind_result%upwind_TI - u(2)%Upwind_result%upwind_TI) + t(2)**2*(-u(1)%Upwind_result%upwind_TI + u(3)%Upwind_result%upwind_TI))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Upwind_result%upwind_TI + t(3)*u(2)%Upwind_result%upwind_TI - t(2)*u(3)%Upwind_result%upwind_TI ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Upwind_result%upwind_TI = u(1)%Upwind_result%upwind_TI + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_small_TI) .AND. ALLOCATED(u(1)%Upwind_result%upwind_small_TI)) THEN
  ALLOCATE(b1(SIZE(u_out%Upwind_result%upwind_small_TI,1)))
  ALLOCATE(c1(SIZE(u_out%Upwind_result%upwind_small_TI,1)))
  b1 = (t(3)**2*(u(1)%Upwind_result%upwind_small_TI - u(2)%Upwind_result%upwind_small_TI) + t(2)**2*(-u(1)%Upwind_result%upwind_small_TI + u(3)%Upwind_result%upwind_small_TI))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Upwind_result%upwind_small_TI + t(3)*u(2)%Upwind_result%upwind_small_TI - t(2)*u(3)%Upwind_result%upwind_small_TI ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Upwind_result%upwind_small_TI = u(1)%Upwind_result%upwind_small_TI + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%upwind_smoothWake) .AND. ALLOCATED(u(1)%Upwind_result%upwind_smoothWake)) THEN
  ALLOCATE(b2(SIZE(u_out%Upwind_result%upwind_smoothWake,1),SIZE(u_out%Upwind_result%upwind_smoothWake,2) ))
  ALLOCATE(c2(SIZE(u_out%Upwind_result%upwind_smoothWake,1),SIZE(u_out%Upwind_result%upwind_smoothWake,2) ))
  b2 = (t(3)**2*(u(1)%Upwind_result%upwind_smoothWake - u(2)%Upwind_result%upwind_smoothWake) + t(2)**2*(-u(1)%Upwind_result%upwind_smoothWake + u(3)%Upwind_result%upwind_smoothWake))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Upwind_result%upwind_smoothWake + t(3)*u(2)%Upwind_result%upwind_smoothWake - t(2)*u(3)%Upwind_result%upwind_smoothWake ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Upwind_result%upwind_smoothWake = u(1)%Upwind_result%upwind_smoothWake + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%velocity_aerodyn) .AND. ALLOCATED(u(1)%Upwind_result%velocity_aerodyn)) THEN
  ALLOCATE(b1(SIZE(u_out%Upwind_result%velocity_aerodyn,1)))
  ALLOCATE(c1(SIZE(u_out%Upwind_result%velocity_aerodyn,1)))
  b1 = (t(3)**2*(u(1)%Upwind_result%velocity_aerodyn - u(2)%Upwind_result%velocity_aerodyn) + t(2)**2*(-u(1)%Upwind_result%velocity_aerodyn + u(3)%Upwind_result%velocity_aerodyn))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Upwind_result%velocity_aerodyn + t(3)*u(2)%Upwind_result%velocity_aerodyn - t(2)*u(3)%Upwind_result%velocity_aerodyn ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Upwind_result%velocity_aerodyn = u(1)%Upwind_result%velocity_aerodyn + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%TI_downstream) .AND. ALLOCATED(u(1)%Upwind_result%TI_downstream)) THEN
  ALLOCATE(b1(SIZE(u_out%Upwind_result%TI_downstream,1)))
  ALLOCATE(c1(SIZE(u_out%Upwind_result%TI_downstream,1)))
  b1 = (t(3)**2*(u(1)%Upwind_result%TI_downstream - u(2)%Upwind_result%TI_downstream) + t(2)**2*(-u(1)%Upwind_result%TI_downstream + u(3)%Upwind_result%TI_downstream))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Upwind_result%TI_downstream + t(3)*u(2)%Upwind_result%TI_downstream - t(2)*u(3)%Upwind_result%TI_downstream ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Upwind_result%TI_downstream = u(1)%Upwind_result%TI_downstream + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%small_scale_TI_downstream) .AND. ALLOCATED(u(1)%Upwind_result%small_scale_TI_downstream)) THEN
  ALLOCATE(b1(SIZE(u_out%Upwind_result%small_scale_TI_downstream,1)))
  ALLOCATE(c1(SIZE(u_out%Upwind_result%small_scale_TI_downstream,1)))
  b1 = (t(3)**2*(u(1)%Upwind_result%small_scale_TI_downstream - u(2)%Upwind_result%small_scale_TI_downstream) + t(2)**2*(-u(1)%Upwind_result%small_scale_TI_downstream + u(3)%Upwind_result%small_scale_TI_downstream))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Upwind_result%small_scale_TI_downstream + t(3)*u(2)%Upwind_result%small_scale_TI_downstream - t(2)*u(3)%Upwind_result%small_scale_TI_downstream ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Upwind_result%small_scale_TI_downstream = u(1)%Upwind_result%small_scale_TI_downstream + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%smoothed_velocity_array) .AND. ALLOCATED(u(1)%Upwind_result%smoothed_velocity_array)) THEN
  ALLOCATE(b2(SIZE(u_out%Upwind_result%smoothed_velocity_array,1),SIZE(u_out%Upwind_result%smoothed_velocity_array,2) ))
  ALLOCATE(c2(SIZE(u_out%Upwind_result%smoothed_velocity_array,1),SIZE(u_out%Upwind_result%smoothed_velocity_array,2) ))
  b2 = (t(3)**2*(u(1)%Upwind_result%smoothed_velocity_array - u(2)%Upwind_result%smoothed_velocity_array) + t(2)**2*(-u(1)%Upwind_result%smoothed_velocity_array + u(3)%Upwind_result%smoothed_velocity_array))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Upwind_result%smoothed_velocity_array + t(3)*u(2)%Upwind_result%smoothed_velocity_array - t(2)*u(3)%Upwind_result%smoothed_velocity_array ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Upwind_result%smoothed_velocity_array = u(1)%Upwind_result%smoothed_velocity_array + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Upwind_result%vel_matrix) .AND. ALLOCATED(u(1)%Upwind_result%vel_matrix)) THEN
  ALLOCATE(b3(SIZE(u_out%Upwind_result%vel_matrix,1),SIZE(u_out%Upwind_result%vel_matrix,2), &
              SIZE(u_out%Upwind_result%vel_matrix,3)                     ))
  ALLOCATE(c3(SIZE(u_out%Upwind_result%vel_matrix,1),SIZE(u_out%Upwind_result%vel_matrix,2), &
              SIZE(u_out%Upwind_result%vel_matrix,3)                     ))
  b3 = (t(3)**2*(u(1)%Upwind_result%vel_matrix - u(2)%Upwind_result%vel_matrix) + t(2)**2*(-u(1)%Upwind_result%vel_matrix + u(3)%Upwind_result%vel_matrix))/(t(2)*t(3)*(t(2) - t(3)))
  c3 = ( (t(2)-t(3))*u(1)%Upwind_result%vel_matrix + t(3)*u(2)%Upwind_result%vel_matrix - t(2)*u(3)%Upwind_result%vel_matrix ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Upwind_result%vel_matrix = u(1)%Upwind_result%vel_matrix + b3 * t_out + c3 * t_out**2
  DEALLOCATE(b3)
  DEALLOCATE(c3)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in DWM_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE DWM_Input_ExtrapInterp


 SUBROUTINE DWM_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(DWM_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(DWM_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in DWM_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in DWM_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%turbine_thrust_force) .AND. ALLOCATED(u(1)%turbine_thrust_force)) THEN
  u_out%turbine_thrust_force = u(1)%turbine_thrust_force
END IF ! check if allocated
IF (ALLOCATED(u_out%induction_factor) .AND. ALLOCATED(u(1)%induction_factor)) THEN
  u_out%induction_factor = u(1)%induction_factor
END IF ! check if allocated
IF (ALLOCATED(u_out%r_initial) .AND. ALLOCATED(u(1)%r_initial)) THEN
  u_out%r_initial = u(1)%r_initial
END IF ! check if allocated
IF (ALLOCATED(u_out%U_initial) .AND. ALLOCATED(u(1)%U_initial)) THEN
  u_out%U_initial = u(1)%U_initial
END IF ! check if allocated
IF (ALLOCATED(u_out%Mean_FFWS_array) .AND. ALLOCATED(u(1)%Mean_FFWS_array)) THEN
  u_out%Mean_FFWS_array = u(1)%Mean_FFWS_array
END IF ! check if allocated
  u_out%Mean_FFWS = u(1)%Mean_FFWS
  u_out%TI = u(1)%TI
  u_out%TI_downstream = u(1)%TI_downstream
IF (ALLOCATED(u_out%wake_u) .AND. ALLOCATED(u(1)%wake_u)) THEN
  u_out%wake_u = u(1)%wake_u
END IF ! check if allocated
IF (ALLOCATED(u_out%wake_position) .AND. ALLOCATED(u(1)%wake_position)) THEN
  u_out%wake_position = u(1)%wake_position
END IF ! check if allocated
IF (ALLOCATED(u_out%smoothed_velocity_array) .AND. ALLOCATED(u(1)%smoothed_velocity_array)) THEN
  u_out%smoothed_velocity_array = u(1)%smoothed_velocity_array
END IF ! check if allocated
  u_out%AtmUscale = u(1)%AtmUscale
  u_out%du_dz_ABL = u(1)%du_dz_ABL
  u_out%total_SDgenpwr = u(1)%total_SDgenpwr
  u_out%mean_SDgenpwr = u(1)%mean_SDgenpwr
  u_out%avg_ct = u(1)%avg_ct
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in DWM_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%turbine_thrust_force) .AND. ALLOCATED(u(1)%turbine_thrust_force)) THEN
  ALLOCATE(b1(SIZE(u_out%turbine_thrust_force,1)))
  ALLOCATE(c1(SIZE(u_out%turbine_thrust_force,1)))
  b1 = -(u(1)%turbine_thrust_force - u(2)%turbine_thrust_force)/t(2)
  u_out%turbine_thrust_force = u(1)%turbine_thrust_force + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%induction_factor) .AND. ALLOCATED(u(1)%induction_factor)) THEN
  ALLOCATE(b1(SIZE(u_out%induction_factor,1)))
  ALLOCATE(c1(SIZE(u_out%induction_factor,1)))
  b1 = -(u(1)%induction_factor - u(2)%induction_factor)/t(2)
  u_out%induction_factor = u(1)%induction_factor + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%r_initial) .AND. ALLOCATED(u(1)%r_initial)) THEN
  ALLOCATE(b1(SIZE(u_out%r_initial,1)))
  ALLOCATE(c1(SIZE(u_out%r_initial,1)))
  b1 = -(u(1)%r_initial - u(2)%r_initial)/t(2)
  u_out%r_initial = u(1)%r_initial + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%U_initial) .AND. ALLOCATED(u(1)%U_initial)) THEN
  ALLOCATE(b1(SIZE(u_out%U_initial,1)))
  ALLOCATE(c1(SIZE(u_out%U_initial,1)))
  b1 = -(u(1)%U_initial - u(2)%U_initial)/t(2)
  u_out%U_initial = u(1)%U_initial + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Mean_FFWS_array) .AND. ALLOCATED(u(1)%Mean_FFWS_array)) THEN
  ALLOCATE(b1(SIZE(u_out%Mean_FFWS_array,1)))
  ALLOCATE(c1(SIZE(u_out%Mean_FFWS_array,1)))
  b1 = -(u(1)%Mean_FFWS_array - u(2)%Mean_FFWS_array)/t(2)
  u_out%Mean_FFWS_array = u(1)%Mean_FFWS_array + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  b0 = -(u(1)%Mean_FFWS - u(2)%Mean_FFWS)/t(2)
  u_out%Mean_FFWS = u(1)%Mean_FFWS + b0 * t_out
  b0 = -(u(1)%TI - u(2)%TI)/t(2)
  u_out%TI = u(1)%TI + b0 * t_out
  b0 = -(u(1)%TI_downstream - u(2)%TI_downstream)/t(2)
  u_out%TI_downstream = u(1)%TI_downstream + b0 * t_out
IF (ALLOCATED(u_out%wake_u) .AND. ALLOCATED(u(1)%wake_u)) THEN
  ALLOCATE(b2(SIZE(u_out%wake_u,1),SIZE(u_out%wake_u,2) ))
  ALLOCATE(c2(SIZE(u_out%wake_u,1),SIZE(u_out%wake_u,2) ))
  b2 = -(u(1)%wake_u - u(2)%wake_u)/t(2)
  u_out%wake_u = u(1)%wake_u + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%wake_position) .AND. ALLOCATED(u(1)%wake_position)) THEN
  ALLOCATE(b3(SIZE(u_out%wake_position,1),SIZE(u_out%wake_position,2), &
              SIZE(u_out%wake_position,3)                     ))
  ALLOCATE(c3(SIZE(u_out%wake_position,1),SIZE(u_out%wake_position,2), &
              SIZE(u_out%wake_position,3)                     ))
  b3 = -(u(1)%wake_position - u(2)%wake_position)/t(2)
  u_out%wake_position = u(1)%wake_position + b3 * t_out
  DEALLOCATE(b3)
  DEALLOCATE(c3)
END IF ! check if allocated
IF (ALLOCATED(u_out%smoothed_velocity_array) .AND. ALLOCATED(u(1)%smoothed_velocity_array)) THEN
  ALLOCATE(b2(SIZE(u_out%smoothed_velocity_array,1),SIZE(u_out%smoothed_velocity_array,2) ))
  ALLOCATE(c2(SIZE(u_out%smoothed_velocity_array,1),SIZE(u_out%smoothed_velocity_array,2) ))
  b2 = -(u(1)%smoothed_velocity_array - u(2)%smoothed_velocity_array)/t(2)
  u_out%smoothed_velocity_array = u(1)%smoothed_velocity_array + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
  b0 = -(u(1)%AtmUscale - u(2)%AtmUscale)/t(2)
  u_out%AtmUscale = u(1)%AtmUscale + b0 * t_out
  b0 = -(u(1)%du_dz_ABL - u(2)%du_dz_ABL)/t(2)
  u_out%du_dz_ABL = u(1)%du_dz_ABL + b0 * t_out
  b0 = -(u(1)%total_SDgenpwr - u(2)%total_SDgenpwr)/t(2)
  u_out%total_SDgenpwr = u(1)%total_SDgenpwr + b0 * t_out
  b0 = -(u(1)%mean_SDgenpwr - u(2)%mean_SDgenpwr)/t(2)
  u_out%mean_SDgenpwr = u(1)%mean_SDgenpwr + b0 * t_out
  b0 = -(u(1)%avg_ct - u(2)%avg_ct)/t(2)
  u_out%avg_ct = u(1)%avg_ct + b0 * t_out
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in DWM_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in DWM_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in DWM_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%turbine_thrust_force) .AND. ALLOCATED(u(1)%turbine_thrust_force)) THEN
  ALLOCATE(b1(SIZE(u_out%turbine_thrust_force,1)))
  ALLOCATE(c1(SIZE(u_out%turbine_thrust_force,1)))
  b1 = (t(3)**2*(u(1)%turbine_thrust_force - u(2)%turbine_thrust_force) + t(2)**2*(-u(1)%turbine_thrust_force + u(3)%turbine_thrust_force))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%turbine_thrust_force + t(3)*u(2)%turbine_thrust_force - t(2)*u(3)%turbine_thrust_force ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%turbine_thrust_force = u(1)%turbine_thrust_force + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%induction_factor) .AND. ALLOCATED(u(1)%induction_factor)) THEN
  ALLOCATE(b1(SIZE(u_out%induction_factor,1)))
  ALLOCATE(c1(SIZE(u_out%induction_factor,1)))
  b1 = (t(3)**2*(u(1)%induction_factor - u(2)%induction_factor) + t(2)**2*(-u(1)%induction_factor + u(3)%induction_factor))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%induction_factor + t(3)*u(2)%induction_factor - t(2)*u(3)%induction_factor ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%induction_factor = u(1)%induction_factor + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%r_initial) .AND. ALLOCATED(u(1)%r_initial)) THEN
  ALLOCATE(b1(SIZE(u_out%r_initial,1)))
  ALLOCATE(c1(SIZE(u_out%r_initial,1)))
  b1 = (t(3)**2*(u(1)%r_initial - u(2)%r_initial) + t(2)**2*(-u(1)%r_initial + u(3)%r_initial))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%r_initial + t(3)*u(2)%r_initial - t(2)*u(3)%r_initial ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%r_initial = u(1)%r_initial + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%U_initial) .AND. ALLOCATED(u(1)%U_initial)) THEN
  ALLOCATE(b1(SIZE(u_out%U_initial,1)))
  ALLOCATE(c1(SIZE(u_out%U_initial,1)))
  b1 = (t(3)**2*(u(1)%U_initial - u(2)%U_initial) + t(2)**2*(-u(1)%U_initial + u(3)%U_initial))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%U_initial + t(3)*u(2)%U_initial - t(2)*u(3)%U_initial ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%U_initial = u(1)%U_initial + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%Mean_FFWS_array) .AND. ALLOCATED(u(1)%Mean_FFWS_array)) THEN
  ALLOCATE(b1(SIZE(u_out%Mean_FFWS_array,1)))
  ALLOCATE(c1(SIZE(u_out%Mean_FFWS_array,1)))
  b1 = (t(3)**2*(u(1)%Mean_FFWS_array - u(2)%Mean_FFWS_array) + t(2)**2*(-u(1)%Mean_FFWS_array + u(3)%Mean_FFWS_array))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%Mean_FFWS_array + t(3)*u(2)%Mean_FFWS_array - t(2)*u(3)%Mean_FFWS_array ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Mean_FFWS_array = u(1)%Mean_FFWS_array + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  b0 = (t(3)**2*(u(1)%Mean_FFWS - u(2)%Mean_FFWS) + t(2)**2*(-u(1)%Mean_FFWS + u(3)%Mean_FFWS))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%Mean_FFWS + t(3)*u(2)%Mean_FFWS - t(2)*u(3)%Mean_FFWS ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Mean_FFWS = u(1)%Mean_FFWS + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%TI - u(2)%TI) + t(2)**2*(-u(1)%TI + u(3)%TI))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%TI + t(3)*u(2)%TI - t(2)*u(3)%TI ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TI = u(1)%TI + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%TI_downstream - u(2)%TI_downstream) + t(2)**2*(-u(1)%TI_downstream + u(3)%TI_downstream))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%TI_downstream + t(3)*u(2)%TI_downstream - t(2)*u(3)%TI_downstream ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TI_downstream = u(1)%TI_downstream + b0 * t_out + c0 * t_out**2
IF (ALLOCATED(u_out%wake_u) .AND. ALLOCATED(u(1)%wake_u)) THEN
  ALLOCATE(b2(SIZE(u_out%wake_u,1),SIZE(u_out%wake_u,2) ))
  ALLOCATE(c2(SIZE(u_out%wake_u,1),SIZE(u_out%wake_u,2) ))
  b2 = (t(3)**2*(u(1)%wake_u - u(2)%wake_u) + t(2)**2*(-u(1)%wake_u + u(3)%wake_u))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%wake_u + t(3)*u(2)%wake_u - t(2)*u(3)%wake_u ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%wake_u = u(1)%wake_u + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%wake_position) .AND. ALLOCATED(u(1)%wake_position)) THEN
  ALLOCATE(b3(SIZE(u_out%wake_position,1),SIZE(u_out%wake_position,2), &
              SIZE(u_out%wake_position,3)                     ))
  ALLOCATE(c3(SIZE(u_out%wake_position,1),SIZE(u_out%wake_position,2), &
              SIZE(u_out%wake_position,3)                     ))
  b3 = (t(3)**2*(u(1)%wake_position - u(2)%wake_position) + t(2)**2*(-u(1)%wake_position + u(3)%wake_position))/(t(2)*t(3)*(t(2) - t(3)))
  c3 = ( (t(2)-t(3))*u(1)%wake_position + t(3)*u(2)%wake_position - t(2)*u(3)%wake_position ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%wake_position = u(1)%wake_position + b3 * t_out + c3 * t_out**2
  DEALLOCATE(b3)
  DEALLOCATE(c3)
END IF ! check if allocated
IF (ALLOCATED(u_out%smoothed_velocity_array) .AND. ALLOCATED(u(1)%smoothed_velocity_array)) THEN
  ALLOCATE(b2(SIZE(u_out%smoothed_velocity_array,1),SIZE(u_out%smoothed_velocity_array,2) ))
  ALLOCATE(c2(SIZE(u_out%smoothed_velocity_array,1),SIZE(u_out%smoothed_velocity_array,2) ))
  b2 = (t(3)**2*(u(1)%smoothed_velocity_array - u(2)%smoothed_velocity_array) + t(2)**2*(-u(1)%smoothed_velocity_array + u(3)%smoothed_velocity_array))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%smoothed_velocity_array + t(3)*u(2)%smoothed_velocity_array - t(2)*u(3)%smoothed_velocity_array ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%smoothed_velocity_array = u(1)%smoothed_velocity_array + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
  b0 = (t(3)**2*(u(1)%AtmUscale - u(2)%AtmUscale) + t(2)**2*(-u(1)%AtmUscale + u(3)%AtmUscale))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%AtmUscale + t(3)*u(2)%AtmUscale - t(2)*u(3)%AtmUscale ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%AtmUscale = u(1)%AtmUscale + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%du_dz_ABL - u(2)%du_dz_ABL) + t(2)**2*(-u(1)%du_dz_ABL + u(3)%du_dz_ABL))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%du_dz_ABL + t(3)*u(2)%du_dz_ABL - t(2)*u(3)%du_dz_ABL ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%du_dz_ABL = u(1)%du_dz_ABL + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%total_SDgenpwr - u(2)%total_SDgenpwr) + t(2)**2*(-u(1)%total_SDgenpwr + u(3)%total_SDgenpwr))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%total_SDgenpwr + t(3)*u(2)%total_SDgenpwr - t(2)*u(3)%total_SDgenpwr ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%total_SDgenpwr = u(1)%total_SDgenpwr + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%mean_SDgenpwr - u(2)%mean_SDgenpwr) + t(2)**2*(-u(1)%mean_SDgenpwr + u(3)%mean_SDgenpwr))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%mean_SDgenpwr + t(3)*u(2)%mean_SDgenpwr - t(2)*u(3)%mean_SDgenpwr ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%mean_SDgenpwr = u(1)%mean_SDgenpwr + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%avg_ct - u(2)%avg_ct) + t(2)**2*(-u(1)%avg_ct + u(3)%avg_ct))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%avg_ct + t(3)*u(2)%avg_ct - t(2)*u(3)%avg_ct ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%avg_ct = u(1)%avg_ct + b0 * t_out + c0 * t_out**2
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in DWM_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE DWM_Output_ExtrapInterp

END MODULE DWM_Types
!ENDOFREGISTRYGENERATEDFILE
